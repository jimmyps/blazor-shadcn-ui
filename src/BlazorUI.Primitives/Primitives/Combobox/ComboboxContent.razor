@namespace BlazorUI.Primitives.Combobox
@using BlazorUI.Primitives.Services
@inject IPositioningService PositioningService
@inject IPortalService PortalService
@inject IJSRuntime JS
@implements IAsyncDisposable

@*
    ComboboxContent primitive - headless listbox container.
    Renders through a portal to avoid z-index stacking issues and clipping.
    Supports smart positioning with IPositioningService.
*@

@if (UsePortal)
{
    @* Hidden element to track DOM position for positioning calculations *@
    @if (_shouldRender)
    {
        <span @ref="_contentRef" style="position: absolute; pointer-events: none; opacity: 0;"></span>
    }
}
else
{
    @* Direct rendering when already inside a portal (e.g., within Popover) *@
    @if (_shouldRender)
    {
        <CascadingValue Value="Context" IsFixed="false">
            <div id="@Context.ContentId"
                 role="listbox"
                 style="@GetMergedStyle()"
                 @attributes="GetAttributesWithoutStyle()">
                @ChildContent
            </div>
        </CascadingValue>
    }
}

@code {
    [CascadingParameter]
    public ComboboxContext Context { get; set; } = null!;

    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Additional attributes to apply to the content element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Preferred side for positioning.
    /// Default is Bottom.
    /// </summary>
    [Parameter]
    public PopoverSide Side { get; set; } = PopoverSide.Bottom;

    /// <summary>
    /// Alignment relative to trigger.
    /// Default is Start.
    /// </summary>
    [Parameter]
    public PopoverAlign Align { get; set; } = PopoverAlign.Start;

    /// <summary>
    /// Offset distance from the trigger element in pixels.
    /// Default is 4.
    /// </summary>
    [Parameter]
    public int Offset { get; set; } = 4;

    /// <summary>
    /// Whether the combobox content should match the input width.
    /// Default is true (common pattern for comboboxes).
    /// </summary>
    [Parameter]
    public bool MatchTriggerWidth { get; set; } = true;

    /// <summary>
    /// Whether to render through a portal.
    /// Set to false when already inside another portal (e.g., Popover).
    /// Default is true.
    /// </summary>
    [Parameter]
    public bool UsePortal { get; set; } = true;

    private ElementReference _contentRef;
    private ElementReference _portalContentRef;
    private bool _shouldRender;
    private IJSObjectReference? _jsModule;
    private IJSObjectReference? _matchWidthModule;
    private IJSObjectReference? _matchWidthCleanup;
    private IAsyncDisposable? _positioningCleanup;
    private bool _isInitialized = false;
    private bool _isPositioned = false;
    private string _portalId = "";
    private TaskCompletionSource<bool>? _portalReadyTcs;

    protected override void OnInitialized()
    {
        if (Context == null)
        {
            throw new InvalidOperationException($"{nameof(ComboboxContent)} must be used within a {nameof(Combobox)} component.");
        }

        _portalId = $"combobox-portal-{Context.ContentId}";

        // Subscribe to context state changes
        Context.OnStateChanged += HandleContextStateChanged;

        // Subscribe to portal ready events for synchronization
        PortalService.OnPortalRendered += HandlePortalRendered;

        // Determine initial render state
        UpdateShouldRender();
    }

    private void HandlePortalRendered(string portalId)
    {
        if (portalId == _portalId)
        {
            _portalReadyTcs?.TrySetResult(true);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _jsModule == null)
        {
            try
            {
                _jsModule = await JS.InvokeAsync<IJSObjectReference>(
                    "import", "./_content/NeoBlazorUI.Primitives/js/primitives/select.js");
            }
            catch
            {
                // JS module not critical, continue without it
            }
        }

        if (_shouldRender && !_isInitialized && UsePortal)
        {
            _isInitialized = true;
            _isPositioned = false;

            // Create completion source BEFORE registering portal
            _portalReadyTcs = new TaskCompletionSource<bool>();

            // Register combobox content through portal - this triggers PortalHost to re-render
            PortalService.RegisterPortal(_portalId, RenderComboboxContent());

            // Wait for PortalHost to signal it's done rendering our portal
            // Use timeout to prevent hanging if something goes wrong
            var timeoutTask = Task.Delay(500);
            var completedTask = await Task.WhenAny(_portalReadyTcs.Task, timeoutTask);

            if (completedTask == timeoutTask)
            {
                Console.WriteLine($"Warning: Portal {_portalId} render timeout");
            }

            // Yield to ensure any pending re-renders complete and _portalContentRef is up-to-date
            await Task.Yield();

            // Check if still should render (user might have closed during wait)
            if (!_shouldRender)
            {
                return;
            }

            // NOW _portalContentRef is guaranteed to be valid!
            await SetupPositioningAsync();
        }
        else if (!_shouldRender && _isInitialized && UsePortal)
        {
            await CleanupAsync();
        }

        // Scroll focused item into view when focus changes
        if (_shouldRender && Context.FocusedIndex >= 0)
        {
            var itemId = Context.GetItemId(Context.FocusedIndex);
            if (_jsModule != null)
            {
                try
                {
                    await _jsModule.InvokeVoidAsync("scrollItemIntoView", itemId);
                }
                catch
                {
                    // Ignore JS errors
                }
            }
        }
    }

    private RenderFragment RenderComboboxContent() => builder =>
    {
        // Re-cascade the context through the portal
        builder.OpenComponent<CascadingValue<ComboboxContext>>(0);
        builder.AddAttribute(1, "Value", Context);
        builder.AddAttribute(2, "IsFixed", false);
        builder.AddAttribute(3, "ChildContent", (RenderFragment)(contentBuilder =>
        {
            contentBuilder.OpenElement(0, "div");
            contentBuilder.AddAttribute(1, "id", Context.ContentId);
            contentBuilder.AddAttribute(2, "role", "listbox");
            contentBuilder.AddAttribute(3, "style", GetMergedStyle());
            contentBuilder.AddMultipleAttributes(4, GetAttributesWithoutStyle());
            contentBuilder.AddElementReferenceCapture(5, capturedRef => _portalContentRef = capturedRef);
            contentBuilder.AddContent(6, ChildContent);
            contentBuilder.CloseElement();
        }));
        builder.CloseComponent();
    };

    private async Task SetupPositioningAsync()
    {
        if (Context.State.InputElement == null)
        {
            Console.WriteLine("Warning: ComboboxContent - InputElement is null, positioning may not work correctly");
            return;
        }

        try
        {
            // Construct placement string from Side and Align
            var placement = Align == PopoverAlign.Center ? Side.ToValue() : $"{Side.ToValue()}-{Align.ToValue()}";

            var options = new PositioningOptions
            {
                Placement = placement,
                Offset = Offset
            };

            // Compute and apply position using the portal content ref
            var position = await PositioningService.ComputePositionAsync(
                Context.State.InputElement.Value,
                _portalContentRef,
                options);

            // Set up width matching BEFORE making visible to prevent flash
            if (MatchTriggerWidth)
            {
                await SetupMatchTriggerWidthAsync();
            }

            // Apply position AND make visible via JS (don't rely on Blazor re-render which would overwrite position)
            await PositioningService.ApplyPositionAsync(_portalContentRef, position, makeVisible: true);

            // Mark as positioned for any future Blazor re-renders
            _isPositioned = true;

            // Set up auto-update for dynamic positioning
            _positioningCleanup = await PositioningService.AutoUpdateAsync(
                Context.State.InputElement.Value,
                _portalContentRef,
                options);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up positioning: {ex.Message}");
            _isPositioned = true;
        }
    }

    private async Task SetupMatchTriggerWidthAsync()
    {
        if (Context.State.InputElement == null) return;

        try
        {
            _matchWidthModule = await JS.InvokeAsync<IJSObjectReference>(
                "import", "./_content/NeoBlazorUI.Primitives/js/primitives/match-trigger-width.js");

            _matchWidthCleanup = await _matchWidthModule.InvokeAsync<IJSObjectReference>(
                "matchTriggerWidth", Context.State.InputElement, _portalContentRef);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up input width matching: {ex.Message}");
        }
    }

    private void HandleContextStateChanged()
    {
        UpdateShouldRender();
        StateHasChanged();
    }

    private void UpdateShouldRender()
    {
        if (!UsePortal)
        {
            // When not using portal (inside Popover/Dialog), always render
            // The parent container controls visibility
            _shouldRender = true;
        }
        else
        {
            // When using portal (standalone), only render when there's an active search query
            // This ensures the dropdown closes after selection
            _shouldRender = !string.IsNullOrEmpty(Context.SearchQuery);
        }
    }

    private string GetInitialStyle()
    {
        if (!UsePortal)
        {
            // No positioning styles needed when not using portal
            return "";
        }

        var baseStyle = "position: absolute; z-index: 50;";

        if (!_isPositioned)
        {
            // Position off-screen initially to prevent focus-induced scroll
            // opacity: 0 alone doesn't prevent browser from scrolling to focused element
            baseStyle += " top: -9999px; left: -9999px; pointer-events: none;";
        }

        return baseStyle;
    }

    private string GetMergedStyle()
    {
        var baseStyle = GetInitialStyle();

        if (AdditionalAttributes != null && AdditionalAttributes.TryGetValue("style", out var userStyle))
        {
            return string.IsNullOrEmpty(baseStyle) ? userStyle?.ToString() ?? "" : $"{userStyle}; {baseStyle}";
        }

        return baseStyle;
    }

    private Dictionary<string, object>? GetAttributesWithoutStyle()
    {
        if (AdditionalAttributes == null) return null;

        var attributes = new Dictionary<string, object>(AdditionalAttributes);
        attributes.Remove("style");

        return attributes.Count > 0 ? attributes : null;
    }

    private async Task CleanupAsync()
    {
        if (_positioningCleanup != null)
        {
            await _positioningCleanup.DisposeAsync();
            _positioningCleanup = null;
        }

        if (_matchWidthCleanup != null)
        {
            try
            {
                await _matchWidthCleanup.InvokeVoidAsync("dispose");
                await _matchWidthCleanup.DisposeAsync();
            }
            catch
            {
                // Cleanup may already be disposed
            }
            _matchWidthCleanup = null;
        }

        // Unregister portal when combobox closes
        if (!string.IsNullOrEmpty(_portalId))
        {
            PortalService.UnregisterPortal(_portalId);
        }

        _isInitialized = false;
        _isPositioned = false;
    }

    public async ValueTask DisposeAsync()
    {
        // Unsubscribe from portal ready events
        PortalService.OnPortalRendered -= HandlePortalRendered;

        await CleanupAsync();

        if (Context != null)
        {
            Context.OnStateChanged -= HandleContextStateChanged;
        }

        if (_jsModule != null)
        {
            try
            {
                await _jsModule.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }

        if (_matchWidthModule != null)
        {
            try
            {
                await _matchWidthModule.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
    }
}
