@namespace BlazorUI.Primitives.Menubar
@using BlazorUI.Primitives.Floating
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

@* MenubarContent - uses FloatingPortal for positioning infrastructure *@

<FloatingPortal PortalId="@MenuContext.ContentId"
                IsOpen="@MenuContext.IsOpen"
                AnchorElement="@MenuContext.TriggerElement"
                Side="@Side"
                Align="@Align"
                ForceMount="false"
                Offset="@Offset"
                ZIndex="@ZIndex"
                OnReady="@HandlePortalReady">
    @* Re-establish cascading values that were lost due to portal rendering to body *@
    <CascadingValue Value="Context" IsFixed="true">
        <CascadingValue Value="MenuContext" IsFixed="true">
            <CascadingValue Value="this" IsFixed="false">
                <div @ref="_contentRef"
                     id="@MenuContext.ContentId"
                     role="menu"
                     tabindex="-1"
                     @attributes="AdditionalAttributes"
                     data-state="open"
                     aria-labelledby="@MenuContext.TriggerId">
                    @ChildContent
                </div>
            </CascadingValue>
        </CascadingValue>
    </CascadingValue>
</FloatingPortal>

@code {
    [CascadingParameter]
    private MenubarContext Context { get; set; } = null!;

    [CascadingParameter]
    private MenubarMenuContext MenuContext { get; set; } = null!;

    /// <summary>
    /// The content to render inside the menu.
    /// Typically contains MenubarItem, MenubarSeparator, etc.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Additional attributes to apply to the content container.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Whether pressing Escape should close the menu.
    /// Default is true.
    /// </summary>
    [Parameter]
    public bool CloseOnEscape { get; set; } = true;

    /// <summary>
    /// Whether clicking outside should close the menu.
    /// Default is true.
    /// </summary>
    [Parameter]
    public bool CloseOnClickOutside { get; set; } = true;

    /// <summary>
    /// Preferred side for positioning.
    /// Default is Bottom.
    /// </summary>
    [Parameter]
    public PopoverSide Side { get; set; } = PopoverSide.Bottom;

    /// <summary>
    /// Alignment relative to trigger.
    /// Default is Start.
    /// </summary>
    [Parameter]
    public PopoverAlign Align { get; set; } = PopoverAlign.Start;

    /// <summary>
    /// Offset distance from the trigger element in pixels.
    /// Default is 4.
    /// </summary>
    [Parameter]
    public int Offset { get; set; } = 4;

    /// <summary>
    /// Whether to enable keyboard loop navigation.
    /// Default is true.
    /// </summary>
    [Parameter]
    public bool Loop { get; set; } = true;

    /// <summary>
    /// Z-index value for the menu content.
    /// Default is 50.
    /// </summary>
    [Parameter]
    public int ZIndex { get; set; } = ZIndexLevels.PopoverContent;

    private ElementReference _contentRef;
    private IJSObjectReference? _clickOutsideModule;
    private IJSObjectReference? _clickOutsideCleanup;
    private IJSObjectReference? _menuKeyboardModule;
    private DotNetObjectReference<MenubarContent>? _dotNetRef;

    // Track menu items for keyboard navigation
    private readonly List<IMenubarItem> _menuItems = new();

    protected override void OnInitialized()
    {
        if (Context == null)
        {
            throw new InvalidOperationException(
                "MenubarContent must be used within a MenubarRoot component.");
        }

        if (MenuContext == null)
        {
            throw new InvalidOperationException(
                "MenubarContent must be used within a MenubarMenu component.");
        }

        // Subscribe to context changes
        Context.OnStateChanged += HandleContextStateChanged;
    }

    // Called by FloatingPortal when content is positioned and visible
    private async Task HandlePortalReady()
    {
        // Set up click-outside detection
        if (CloseOnClickOutside)
        {
            await SetupClickOutsideAsync();
        }

        // Set up keyboard navigation with menubar mode
        await SetupKeyboardNavAsync();
    }

    private async Task SetupClickOutsideAsync()
    {
        try
        {
            _clickOutsideModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/NeoBlazorUI.Primitives/js/primitives/click-outside.js");

            _dotNetRef = DotNetObjectReference.Create(this);

            // Pass trigger element to exclude it from click-outside detection
            _clickOutsideCleanup = await _clickOutsideModule.InvokeAsync<IJSObjectReference>(
                "onClickOutside", _contentRef, _dotNetRef, "HandleClickOutside", MenuContext.TriggerElement);
        }
        catch (JSDisconnectedException)
        {
            // Expected during circuit disconnect in Blazor Server
        }
        catch (InvalidOperationException)
        {
            // JS interop not available during prerendering
        }
    }

    private async Task SetupKeyboardNavAsync()
    {
        try
        {
            _menuKeyboardModule ??= await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/NeoBlazorUI.Primitives/js/primitives/menu-keyboard.js");

            _dotNetRef ??= DotNetObjectReference.Create(this);

            await _menuKeyboardModule.InvokeVoidAsync("initialize", _contentRef, _dotNetRef, MenuContext.ContentId,
                new { mode = "menubar", loop = Loop, initialFocus = "container" });
        }
        catch (JSDisconnectedException)
        {
            // Expected during circuit disconnect in Blazor Server
        }
        catch (InvalidOperationException)
        {
            // JS interop not available during prerendering
        }
    }

    [JSInvokable]
    public Task HandleClickOutside()
    {
        if (!MenuContext.IsOpen) return Task.CompletedTask;

        if (CloseOnClickOutside)
        {
            Context.CloseMenu();
        }

        return Task.CompletedTask;
    }

    private async void HandleContextStateChanged()
    {
        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public Task JsOnEscapeKey()
    {
        if (CloseOnEscape)
        {
            Context.CloseMenu();
        }
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task JsOnNextMenu()
    {
        Context.FocusNextTrigger();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task JsOnPreviousMenu()
    {
        Context.FocusPreviousTrigger();
        return Task.CompletedTask;
    }

    private async Task CleanupAsync()
    {
        if (_clickOutsideCleanup != null)
        {
            try
            {
                await _clickOutsideCleanup.InvokeVoidAsync("dispose");
                await _clickOutsideCleanup.DisposeAsync();
            }
            catch
            {
                // Cleanup may already be disposed
            }
            _clickOutsideCleanup = null;
        }

        if (_menuKeyboardModule != null)
        {
            try
            {
                await _menuKeyboardModule.InvokeVoidAsync("dispose", MenuContext.ContentId);
            }
            catch
            {
                // Cleanup may already be disposed
            }
        }

        // Dispose DotNetObjectReference to prevent stale callbacks
        if (_dotNetRef != null)
        {
            _dotNetRef.Dispose();
            _dotNetRef = null;
        }
    }

    public async ValueTask DisposeAsync()
    {
        await CleanupAsync();

        if (_clickOutsideModule != null)
        {
            await _clickOutsideModule.DisposeAsync();
        }

        if (_menuKeyboardModule != null)
        {
            await _menuKeyboardModule.DisposeAsync();
        }

        _dotNetRef?.Dispose();

        if (Context != null)
        {
            Context.OnStateChanged -= HandleContextStateChanged;
        }
    }

    /// <summary>
    /// Registers a menu item for keyboard navigation.
    /// </summary>
    internal void RegisterMenuItem(IMenubarItem item)
    {
        if (!_menuItems.Contains(item))
        {
            _menuItems.Add(item);
        }
    }

    /// <summary>
    /// Unregisters a menu item.
    /// </summary>
    internal void UnregisterMenuItem(IMenubarItem item)
    {
        _menuItems.Remove(item);
    }

    /// <summary>
    /// Focuses the content container for keyboard navigation.
    /// </summary>
    internal async Task FocusContainerAsync()
    {
        try
        {
            await _contentRef.FocusAsync();
        }
        catch
        {
            // Focus failed
        }
    }
}
