@namespace BlazorUI.Primitives.Menubar
@using BlazorUI.Primitives.Floating
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

@*
    MenubarSubContent - the content panel for a submenu
    Uses FloatingPortal for positioning infrastructure.
*@

@if (SubContext.IsOpen && SubContext.TriggerElement.HasValue)
{
    <FloatingPortal IsOpen="@SubContext.IsOpen"
                    AnchorElement="@SubContext.TriggerElement"
                    PortalId="@_portalId"
                    ParentPortalId="@GetParentPortalId()"
                    ForceMount="false"
                    Side="PopoverSide.Right"
                    Align="PopoverAlign.Start"
                    Offset="@Offset"
                    Strategy="PositioningStrategy.Fixed"
                    ZIndex="@EffectiveZIndex"
                    OnReady="@HandleFloatingReady">
        @RenderSubMenuContent()
    </FloatingPortal>
}

@code {
[CascadingParameter]
private MenubarContext? MenuContext { get; set; }

[CascadingParameter]
private MenubarSubContext SubContext { get; set; } = null!;

[CascadingParameter(Name = "ParentSubContext")]
private MenubarSubContext? ParentSubContext { get; set; }

[CascadingParameter]
private MenubarMenuContext? MenubarMenuContext { get; set; }

private ElementReference _contentRef;
private string _portalId = "";
private string _instanceId = "";
private IJSObjectReference? _menuKeyboardModule;
private DotNetObjectReference<MenubarSubContent>? _dotNetRef;

// Track menu items for keyboard navigation (still needed for registration)
private readonly List<IMenubarItem> _menuItems = new();

    /// <summary>
    /// The content to render inside the submenu.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Additional attributes to apply to the content container.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Whether pressing Escape should close the submenu.
    /// Default is true.
    /// </summary>
    [Parameter]
    public bool CloseOnEscape { get; set; } = true;

    /// <summary>
    /// Offset distance from the trigger element in pixels.
    /// Default is -4 (slight overlap with parent).
    /// </summary>
    [Parameter]
    public int Offset { get; set; } = -4;

    /// <summary>
    /// Z-index value for the submenu content.
    /// Default is calculated as ZIndexLevels.PopoverContent + depth to ensure proper stacking.
    /// Can be overridden for custom z-index behavior.
    /// </summary>
    [Parameter]
    public int? ZIndex { get; set; }

    /// <summary>
    /// Gets the effective z-index value, calculating from depth if not explicitly set.
    /// </summary>
    private int EffectiveZIndex => 9999; // Use special zIndex value for sub menus

    protected override void OnInitialized()
    {
        if (SubContext == null)
        {
            throw new InvalidOperationException(
                "MenubarSubContent must be used within a MenubarSub component.");
        }

        _portalId = $"menubar-submenu-{SubContext.GetHashCode()}";
        _instanceId = $"menubar-sub-{SubContext.GetHashCode()}";
        SubContext.OnStateChanged += HandleContextStateChanged;
    }

    /// <summary>
    /// Gets the parent portal ID for hierarchical portal nesting.
    /// ALL children append to the root portal, regardless of nesting depth.
    /// This ensures only one portal exists for the entire menu hierarchy.
    /// </summary>
    private string? GetParentPortalId()
    {
        // Always append to root portal, even if this is a nested submenu
        // The parent-child UI relationship is maintained through composite rendering,
        // but all children are siblings in the portal scope
        // MenubarContent uses MenuContext.ContentId as its portal ID
        return MenubarMenuContext != null ? MenubarMenuContext.ContentId : null;
    }

    private RenderFragment RenderSubMenuContent() => __builder =>
    {
        <div @ref="_contentRef"
             role="menu"
             tabindex="-1"
             @onmouseleave="HandleMouseLeave"
             @attributes="AdditionalAttributes"
             data-state="open">
            @* Re-cascade MenuContext since FloatingPortal breaks cascading chain *@
            <CascadingValue Value="MenuContext" IsFixed="false">
                @* CRITICAL: Also cascade as MenubarMenuContext for nested submenus to receive *@
                <CascadingValue Value="MenubarMenuContext" IsFixed="false">
                    <CascadingValue Value="@this" IsFixed="false">
                        <CascadingValue Value="@SubContext" Name="ParentSubContext" IsFixed="false">
                            @ChildContent
                        </CascadingValue>
                    </CascadingValue>
                </CascadingValue>
            </CascadingValue>
        </div>
    };

    private async Task HandleFloatingReady()
    {
        // Set up JavaScript keyboard navigation with submenu mode
        await SetupKeyboardNavAsync();
    }

    private async Task SetupKeyboardNavAsync()
    {
        try
        {
            _menuKeyboardModule ??= await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/NeoBlazorUI.Primitives/js/primitives/menu-keyboard.js");

            _dotNetRef ??= DotNetObjectReference.Create(this);

            await _menuKeyboardModule.InvokeVoidAsync("initialize", _contentRef, _dotNetRef, _instanceId,
                new { mode = "submenu", loop = true, initialFocus = "container" });
        }
        catch (JSDisconnectedException)
        {
            // Expected during circuit disconnect in Blazor Server
        }
        catch (InvalidOperationException)
        {
            // JS interop not available during prerendering
        }
    }

    private void HandleContextStateChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public Task JsOnEscapeKey()
    {
        if (CloseOnEscape)
        {
            // Close ALL menus including root when Escape is pressed
            MenuContext?.CloseMenu();
        }
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task JsOnCloseSubMenu()
    {
        // Close this submenu and return focus to trigger
        SubContext.Close();

        // Restore focus to the trigger element
        if (SubContext.TriggerElement.HasValue)
        {
            try
            {
                await SubContext.TriggerElement.Value.FocusAsync();
            }
            catch
            {
                // Focus failed
            }
        }
    }

    private void HandleMouseLeave(MouseEventArgs args)
    {
        // Don't close on mouse leave - closing is handled by:
        // 1. Hovering sibling menu items (which call CloseActiveSubMenu)
        // 2. Keyboard navigation (ArrowLeft, Escape)
        // This prevents the submenu from closing when moving mouse to its own items
    }

    public async ValueTask DisposeAsync()
    {
        SubContext.OnStateChanged -= HandleContextStateChanged;

        // Clean up menu keyboard module
        if (_menuKeyboardModule != null)
        {
            try
            {
                await _menuKeyboardModule.InvokeVoidAsync("dispose", _instanceId);
            }
            catch { }

            try
            {
                await _menuKeyboardModule.DisposeAsync();
            }
            catch { }
            _menuKeyboardModule = null;
        }

        _dotNetRef?.Dispose();
        _dotNetRef = null;
    }

    /// <summary>
    /// Registers a menu item for keyboard navigation.
    /// </summary>
    internal void RegisterMenuItem(IMenubarItem item)
    {
        if (!_menuItems.Contains(item))
        {
            _menuItems.Add(item);
        }
    }

    /// <summary>
    /// Unregisters a menu item.
    /// </summary>
    internal void UnregisterMenuItem(IMenubarItem item)
    {
        _menuItems.Remove(item);
    }

    /// <summary>
    /// Focuses the content container for keyboard navigation.
    /// </summary>
    internal async Task FocusContainerAsync()
    {
        try
        {
            await _contentRef.FocusAsync();
        }
        catch
        {
            // Focus failed
        }
    }
}
