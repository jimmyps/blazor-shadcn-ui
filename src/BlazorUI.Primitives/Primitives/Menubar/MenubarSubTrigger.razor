@namespace BlazorUI.Primitives.Menubar
@implements IMenubarItem
@implements IDisposable

@* MenubarSubTrigger - triggers opening of a submenu *@
<div @ref="_triggerRef"
     role="menuitem"
     tabindex="-1"
     aria-haspopup="menu"
     aria-expanded="@SubContext.IsOpen.ToString().ToLower()"
     aria-disabled="@Disabled.ToString().ToLower()"
     @onclick="HandleClick"
     @onmouseenter="HandleMouseEnter"
     @onmouseleave="HandleMouseLeave"
     data-state="@(SubContext.IsOpen ? "open" : "closed")"
     data-disabled="@(Disabled ? "true" : null)"
     @attributes="AdditionalAttributes">
    @ChildContent
</div>

@code {
    [CascadingParameter]
    private MenubarContext? MenuContext { get; set; }

    [CascadingParameter]
    private MenubarSubContext SubContext { get; set; } = null!;

    [CascadingParameter]
    private MenubarContent? ContentContext { get; set; }

    [CascadingParameter(Name = "ParentSubContext")]
    private MenubarSubContext? ParentSubContext { get; set; }

    [CascadingParameter]
    private MenubarSubContent? SubContentContext { get; set; }

    private ElementReference _triggerRef;
    private CancellationTokenSource? _hoverCts;

    /// <summary>
    /// The content to display inside the trigger.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Additional attributes to apply to the trigger element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Whether the trigger is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; } = false;

    protected override void OnInitialized()
    {
        if (SubContext == null)
        {
            throw new InvalidOperationException(
                "MenubarSubTrigger must be used within a MenubarSub component.");
        }

        // Register this item with the appropriate content for keyboard navigation
        // If we're inside a submenu, register with the submenu content
        // Otherwise, register with the root menu content
        if (SubContentContext != null)
        {
            SubContentContext.RegisterMenuItem(this);
        }
        else
        {
            ContentContext?.RegisterMenuItem(this);
        }

        // Subscribe to state changes to update aria-expanded when submenu is closed externally
        SubContext.OnStateChanged += HandleStateChanged;
    }

    private void HandleStateChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    protected override void OnAfterRender(bool firstRender)
    {
        // Always update the trigger element reference
        SubContext.TriggerElement = _triggerRef;
    }

    private void HandleClick(MouseEventArgs args)
    {
        if (Disabled) return;

        if (SubContext.IsOpen)
        {
            SubContext.Close();
        }
        else
        {
            // Register as active submenu on parent so the close chain works
            // (HandleMouseEnter does this for hover, but click/keyboard needs it too)
            if (ParentSubContext != null)
            {
                ParentSubContext.ActiveSubMenu = SubContext;
            }
            else if (MenuContext != null)
            {
                MenuContext.ActiveSubMenu = SubContext;
            }

            SubContext.Open(_triggerRef);
        }
    }

    private async Task HandleMouseEnter(MouseEventArgs args)
    {
        if (Disabled) return;

        // If this submenu is already open and registered as active, there is nothing to do.
        // Avoid the close-then-reopen flicker that would occur if we fell through to the
        // CloseActiveSubMenu + Task.Delay(300) + Open path.
        bool isAlreadyActive = ParentSubContext != null
            ? ParentSubContext.ActiveSubMenu == SubContext
            : MenuContext?.ActiveSubMenu == SubContext;

        if (isAlreadyActive && SubContext.IsOpen)
        {
            _hoverCts?.Cancel();
            return;
        }

        // Cancel any in-flight hover operation from a previous rapid mouse-enter
        _hoverCts?.Cancel();
        _hoverCts?.Dispose();
        _hoverCts = new CancellationTokenSource();
        var token = _hoverCts.Token;

        // Close any sibling submenu immediately and register ours as the active one.
        // This must happen before the delay: keeping a sibling's panel open during the
        // wait can cause it to overlap this trigger, firing a spurious mouseleave that
        // cancels the pending open. It also avoids showing two "selected" triggers at once.
        bool hadActiveSubmenu = false;

        if (ParentSubContext != null)
        {
            hadActiveSubmenu = ParentSubContext.ActiveSubMenu != null && ParentSubContext.ActiveSubMenu != SubContext;
            ParentSubContext.CloseActiveSubMenu();
            ParentSubContext.ActiveSubMenu = SubContext;
        }
        else
        {
            hadActiveSubmenu = MenuContext?.ActiveSubMenu != null && MenuContext?.ActiveSubMenu != SubContext;
            MenuContext?.CloseActiveSubMenu();
            if (MenuContext != null)
            {
                MenuContext.ActiveSubMenu = SubContext;
            }
        }

        // Delay before opening: prevents the submenu from flashing open when the cursor
        // merely passes through this trigger. HandleMouseLeave cancels the token so a
        // quick pass-through is a no-op.
        try
        {
            await Task.Delay(300, token);
        }
        catch (OperationCanceledException)
        {
            return;
        }

        SubContext.Open(_triggerRef);

        // Focus this trigger only if we replaced another submenu (for keyboard navigation to work)
        if (hadActiveSubmenu)
        {
            await FocusAsync();
        }
    }

    private void HandleMouseLeave(MouseEventArgs args)
    {
        // Cancel any pending hover-open so a quick mouse-pass-through doesn't open the submenu
        _hoverCts?.Cancel();
    }

    // IMenubarItem implementation
    public async Task FocusAsync()
    {
        try
        {
            await _triggerRef.FocusAsync();
        }
        catch
        {
            // Ignore focus errors
        }
    }

    public async Task ClickAsync()
    {
        if (Disabled) return;
        HandleClick(new MouseEventArgs());
        await Task.CompletedTask;
    }

    public void Dispose()
    {
        _hoverCts?.Cancel();
        _hoverCts?.Dispose();
        // Unregister this item when disposed
        if (SubContentContext != null)
        {
            SubContentContext.UnregisterMenuItem(this);
        }
        else
        {
            ContentContext?.UnregisterMenuItem(this);
        }
        SubContext.OnStateChanged -= HandleStateChanged;
    }
}
