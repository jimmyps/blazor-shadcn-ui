@typeparam TValue
@namespace BlazorUI.Primitives.Select
@using BlazorUI.Primitives.Floating
@using BlazorUI.Primitives.Services
@using Microsoft.JSInterop
@inject IJSRuntime JS
@implements IAsyncDisposable

@*
    SelectContent primitive - headless dropdown container.
    Uses FloatingPortal for portal/positioning infrastructure.
    Maintains Select-specific behavior: keyboard navigation, item focus, ARIA attributes.
*@

<FloatingPortal IsOpen="@(_context?.IsOpen == true)"
                AnchorElement="@_context?.State.TriggerElement"
                PortalId="@_portalId"
                Side="@Side"
                Align="@Align"
                Offset="@Offset"
                ForceMount="@ForceMount"
                MatchAnchorWidth="@MatchTriggerWidth"
                Strategy="PositioningStrategy.Fixed"
                ZIndex="9999"
                OnReady="@HandleFloatingReady">
    @RenderSelectListbox()
</FloatingPortal>

@code {
    [CascadingParameter]
    private SelectContext<TValue>? _context { get; set; }

    private IJSObjectReference? _jsModule;
    private IJSObjectReference? _clickOutsideModule;
    private IJSObjectReference? _clickOutsideCleanup;
    private DotNetObjectReference<SelectContent<TValue>>? _dotNetRef;
    private bool _isKeyboardSetup = false;
    private bool _isClickOutsideSetup = false;
    private string _portalId = "";

    /// <summary>
    /// Content to render inside the select dropdown.
    /// Typically contains SelectItem components.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Whether to keep the content mounted when closed.
    /// When true, items stay registered and DisplayText resolves immediately.
    /// Default is true for Select (small choice sets).
    /// </summary>
    [Parameter]
    public bool ForceMount { get; set; } = true;

    /// <summary>
    /// Additional attributes to be applied to the content container.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Preferred side for positioning.
    /// Default is Bottom.
    /// </summary>
    [Parameter]
    public PopoverSide Side { get; set; } = PopoverSide.Bottom;

    /// <summary>
    /// Alignment relative to trigger.
    /// Default is Start.
    /// </summary>
    [Parameter]
    public PopoverAlign Align { get; set; } = PopoverAlign.Start;

    /// <summary>
    /// Offset distance from the trigger element in pixels.
    /// Default is 4.
    /// </summary>
    [Parameter]
    public int Offset { get; set; } = 4;

    /// <summary>
    /// Whether the select content should match the trigger width.
    /// Default is true (common pattern for selects).
    /// </summary>
    [Parameter]
    public bool MatchTriggerWidth { get; set; } = true;

    protected override void OnInitialized()
    {
        if (_context == null)
        {
            throw new InvalidOperationException(
                "SelectContent must be used within a Select component. " +
                "Ensure SelectContent is a child of a Select component.");
        }

        _portalId = $"select-portal-{_context.ContentId}";

        // Subscribe to context state changes for cleanup
        _context.OnStateChanged += HandleContextStateChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _jsModule == null)
        {
            _jsModule = await JS.InvokeAsync<IJSObjectReference>(
                "import", "./_content/NeoBlazorUI.Primitives/js/primitives/select.js");
        }
    }

    private RenderFragment RenderSelectListbox() => builder =>
    {
        // Re-cascade the SelectContext through the portal so SelectItem components can access it
        builder.OpenComponent<CascadingValue<SelectContext<TValue>>>(0);
        builder.AddAttribute(1, "Value", _context);
        builder.AddAttribute(2, "IsFixed", false);
        builder.AddAttribute(3, "ChildContent", (RenderFragment)(contentBuilder =>
        {
            contentBuilder.OpenElement(0, "div");
            contentBuilder.AddAttribute(1, "id", _context!.ContentId);
            contentBuilder.AddAttribute(2, "role", "listbox");
            contentBuilder.AddAttribute(3, "aria-labelledby", _context.TriggerId);
            contentBuilder.AddAttribute(4, "aria-activedescendant", GetActiveDescendantId());
            contentBuilder.AddAttribute(5, "data-select-content", "true");
            // CRITICAL: data-state must reflect actual open state for CSS animations
            contentBuilder.AddAttribute(6, "data-state", _context.IsOpen ? "open" : "closed");
            contentBuilder.AddAttribute(7, "data-side", GetDataSide());
            contentBuilder.AddAttribute(8, "tabindex", "-1");
            contentBuilder.AddMultipleAttributes(9, AdditionalAttributes);
            contentBuilder.AddContent(10, ChildContent);
            contentBuilder.CloseElement();
        }));
        builder.CloseComponent();
    };

    private async Task HandleFloatingReady()
    {
        if (_context == null || _jsModule == null) return;

        // CRITICAL: Scroll to selected item and set visual focus
        // This runs on EVERY open (including subsequent opens with ForceMount)
        var selectedValue = _context.State.Value?.ToString();
        await _jsModule.InvokeVoidAsync("focusInitialOption", _context.ContentId, selectedValue);

        // Focus the selected item or first item (updates Blazor state)
        _context.FocusSelectedOrFirst();

        // Set up click-outside detection
        // With ForceMount: setup once and reuse
        // Without ForceMount: setup on every open (cleanup happens on close)
        if (!_isClickOutsideSetup)
        {
            await SetupClickOutsideAsync();
            _isClickOutsideSetup = true;
        }

        // Set up JavaScript-based keyboard navigation
        // With ForceMount: setup once and reuse
        // Without ForceMount: setup on every open (cleanup happens on close)
        if (!_isKeyboardSetup)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            await _jsModule.InvokeVoidAsync("setupKeyboardNavigation", _context.ContentId, _dotNetRef);
            _isKeyboardSetup = true;
        }
        
        // CRITICAL: Focus the container on EVERY open (for keyboard navigation)
        // This is separate from setup - needed even when handlers already exist
        await _jsModule.InvokeVoidAsync("focusContent", _context.ContentId);
    }

    private async Task SetupClickOutsideAsync()
    {
        if (_context == null) return;

        try
        {
            _clickOutsideModule = await JS.InvokeAsync<IJSObjectReference>(
                "import", "./_content/NeoBlazorUI.Primitives/js/primitives/click-outside.js");

            if (_dotNetRef == null)
            {
                _dotNetRef = DotNetObjectReference.Create(this);
            }

            // Use ID-based lookup instead of ElementReference
            _clickOutsideCleanup = await _clickOutsideModule.InvokeAsync<IJSObjectReference>(
                "onClickOutsideByIds",
                _context.ContentId,      // Element ID (not ElementReference)
                _dotNetRef,
                "HandleClickOutside",
                _context.TriggerId);     // Trigger ID (not ElementReference)
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up click-outside: {ex.Message}");
        }
    }

    private async void HandleContextStateChanged()
    {
        // When context closes, clean up ONLY if not using ForceMount
        // With ForceMount, handlers stay active and cleanup only on component disposal
        if (_context?.IsOpen == false && _isKeyboardSetup && !ForceMount)
        {
            await InvokeAsync(async () =>
            {
                await CleanupSelectAsync();
                StateHasChanged();
            });
        }
    }

    private string? GetActiveDescendantId()
    {
        if (_context != null && _context.FocusedIndex >= 0)
        {
            return $"{_context.ContentId}-item-{_context.FocusedIndex}";
        }
        return null;
    }

    private async Task CleanupSelectAsync()
    {
        // Clean up keyboard navigation
        if (_jsModule != null && _context != null && _isKeyboardSetup)
        {
            try
            {
                await _jsModule.InvokeVoidAsync("cleanupKeyboardNavigation", _context.ContentId);
            }
            catch
            {
                // JS module may be disposed
            }
            _isKeyboardSetup = false;
        }

        // Clean up click-outside listener
        if (_clickOutsideCleanup != null)
        {
            try
            {
                await _clickOutsideCleanup.InvokeVoidAsync("dispose");
                await _clickOutsideCleanup.DisposeAsync();
            }
            catch
            {
                // Cleanup may already be disposed
            }
            _clickOutsideCleanup = null;
            _isClickOutsideSetup = false;
        }
    }

    /// <summary>
    /// Called from JavaScript when clicking outside the select.
    /// </summary>
    [JSInvokable]
    public void HandleClickOutside()
    {
        if (_context.IsOpen)
            _context?.Close();
    }

    /// <summary>
    /// Called from JavaScript when the Escape key is pressed.
    /// </summary>
    [JSInvokable]
    public void HandleEscapeKey()
    {
        _context?.Close();
    }

    /// <summary>
    /// Called from JavaScript when the Tab key is pressed.
    /// </summary>
    [JSInvokable]
    public void HandleTabKey()
    {
        _context?.Close();
    }

    /// <summary>
    /// Gets the data-side attribute value based on the Side parameter.
    /// </summary>
    private string GetDataSide()
    {
        return Side switch
        {
            PopoverSide.Top => "top",
            PopoverSide.Bottom => "bottom",
            PopoverSide.Left => "left",
            PopoverSide.Right => "right",
            _ => "bottom"
        };
    }

    public async ValueTask DisposeAsync()
    {
        if (_context != null)
        {
            _context.OnStateChanged -= HandleContextStateChanged;
        }

        await CleanupSelectAsync();

        if (_clickOutsideModule != null)
        {
            await _clickOutsideModule.DisposeAsync();
        }

        if (_jsModule != null)
        {
            await _jsModule.DisposeAsync();
        }

        _dotNetRef?.Dispose();
    }
}
