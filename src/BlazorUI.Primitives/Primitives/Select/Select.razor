@typeparam TValue
@namespace BlazorUI.Primitives.Select
@implements IDisposable
@inject BlazorUI.Primitives.Services.DropdownManagerService? DropdownManager

@* Select root component - headless, unstyled behavior only *@
<CascadingValue Value="@_context" IsFixed="false">
    <div @attributes="AdditionalAttributes">
        @ChildContent
    </div>
</CascadingValue>

@code {
    private SelectContext<TValue> _context = new();
    private UseControllableState<TValue?> _state = null!;

    /// <summary>
    /// The child content to render within the select context.
    /// Typically includes SelectTrigger and SelectContent.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Additional attributes to apply to the root element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// The currently selected value (controlled mode).
    /// When null, the select manages its own state (uncontrolled mode).
    /// </summary>
    [Parameter]
    public TValue? Value { get; set; }

    /// <summary>
    /// Event callback invoked when the selected value changes.
    /// Use with @bind-Value for two-way binding.
    /// </summary>
    [Parameter]
    public EventCallback<TValue?> ValueChanged { get; set; }

    /// <summary>
    /// Default value when in uncontrolled mode.
    /// </summary>
    [Parameter]
    public TValue? DefaultValue { get; set; }

    /// <summary>
    /// Event callback invoked when the select value changes.
    /// Receives the new value as a parameter.
    /// </summary>
    [Parameter]
    public EventCallback<TValue?> OnValueChange { get; set; }

    /// <summary>
    /// Whether the select is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Controls whether the select dropdown is open (controlled mode).
    /// When null, the select manages its own open state (uncontrolled mode).
    /// </summary>
    [Parameter]
    public bool? Open { get; set; }

    /// <summary>
    /// Event callback invoked when the open state changes.
    /// Use with @bind-Open for two-way binding.
    /// </summary>
    [Parameter]
    public EventCallback<bool> OpenChanged { get; set; }

    /// <summary>
    /// Default open state when in uncontrolled mode.
    /// </summary>
    [Parameter]
    public bool DefaultOpen { get; set; } = false;

    /// <summary>
    /// Optional function to derive display text from the selected value.
    /// Use this when you have a pre-selected value and want to show its display text
    /// without waiting for the dropdown items to render and register.
    /// This keeps display text in sync automatically when the value changes.
    /// </summary>
    [Parameter]
    public Func<TValue, string>? DisplayTextSelector { get; set; }

    protected override void OnInitialized()
    {
        // Initialize controllable state for value
        _state = new UseControllableState<TValue?>(DefaultValue)
        {
            ControlledValue = Value,
            OnValueChanged = ValueChanged,
            IsControlled = ValueChanged.HasDelegate
        };

        // Sync initial value to context
        _context.State.Value = _state.Value;
        _context.State.Disabled = Disabled;
        // Set initial DisplayText - use DisplayTextSelector if provided, otherwise fall back to Value.ToString()
        // (will be updated when items register with correct display text if dropdown is opened)
        _context.State.DisplayText = GetDisplayText(_state.Value);

        // Subscribe to context value changes
        _context.OnValueChange = async (newValue) =>
        {
            await _state.SetValueAsync(newValue);

            if (OnValueChange.HasDelegate)
            {
                await OnValueChange.InvokeAsync(newValue);
            }

            StateHasChanged();
        };

        // Subscribe to context state changes
        _context.OnStateChanged += HandleContextStateChanged;
    }

    protected override void OnParametersSet()
    {
        // Update disabled state
        if (_context.Disabled != Disabled)
        {
            _context.SetDisabled(Disabled);
        }

        // Update controlled value if it changed
        if (_state.IsControlled)
        {
            _state.ControlledValue = Value;
            _context.State.Value = Value;
            // Update DisplayText - try to look up from registered items first,
            // then use DisplayTextSelector if provided, finally fall back to Value.ToString()
            _context.State.DisplayText = _context.GetDisplayTextForValue(Value) ?? GetDisplayText(Value);
        }

        // Handle controlled open state
        if (Open.HasValue && _context.IsOpen != Open.Value)
        {
            if (Open.Value)
            {
                _context.Open();
            }
            else
            {
                _context.Close();
            }
        }
    }

    private void HandleContextStateChanged()
    {
        // Register/unregister with dropdown manager when open state changes
        if (DropdownManager != null)
        {
            if (_context.IsOpen)
            {
                // Register this dropdown as open; if another is open, it will be closed
                DropdownManager.RegisterOpen(_context.ContentId, () =>
                {
                    _context.Close();
                    InvokeAsync(StateHasChanged); // Ensure UI thread synchronization
                });
            }
            else
            {
                // Unregister when closed naturally
                DropdownManager.Unregister(_context.ContentId);
            }
        }

        // When context state changes (e.g., from SelectTrigger or click outside),
        // notify parent if Open is being controlled
        if (OpenChanged.HasDelegate)
        {
            var newOpenState = _context.IsOpen;
            if (!Open.HasValue || Open.Value != newOpenState)
            {
                _ = OpenChanged.InvokeAsync(newOpenState);
            }
        }

        StateHasChanged();
    }

    /// <summary>
    /// Gets the display text for a value using the DisplayTextSelector if available,
    /// otherwise falls back to Value.ToString().
    /// </summary>
    private string? GetDisplayText(TValue? value)
    {
        if (value == null) return null;
        if (DisplayTextSelector != null) return DisplayTextSelector(value);
        return value.ToString();
    }

    public void Dispose()
    {
        _context.OnStateChanged -= HandleContextStateChanged;

        // Unregister from dropdown manager on dispose
        if (DropdownManager != null && _context?.IsOpen == true)
        {
            DropdownManager.Unregister(_context.ContentId);
        }
    }
}
