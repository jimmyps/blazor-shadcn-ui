@namespace BlazorUI.Primitives.NavigationMenu
@implements IDisposable

@* NavigationMenuContent - dropdown content panel *@
@if (ForceMount || IsActive || IsClosing)
{
    <div id="@ItemContext.ContentId"
         @onmouseleave="HandleMouseLeave"
         @onmouseenter="HandleMouseEnter"
         @attributes="AdditionalAttributes"
         role="menu"
         aria-labelledby="@ItemContext.TriggerId"
         data-state="@GetDataState()"
         data-motion="@GetDataMotion()"
         style="@GetStyle()">
        @ChildContent
    </div>
}

@code {
    [CascadingParameter]
    private NavigationMenuContext Context { get; set; } = null!;

    [CascadingParameter]
    private NavigationMenuItemContext ItemContext { get; set; } = null!;

    /// <summary>
    /// The child content to render within the content panel.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// When true, the content is always mounted in the DOM (for animations).
    /// </summary>
    [Parameter]
    public bool ForceMount { get; set; }

    /// <summary>
    /// Additional attributes to apply to the content element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    private bool IsActive => Context?.IsItemActive(ItemContext?.Value ?? string.Empty) ?? false;
    private bool IsClosing { get; set; }
    private bool WasActive { get; set; }
    private System.Threading.Timer? _closingTimer;

    protected override void OnInitialized()
    {
        if (Context == null)
        {
            throw new InvalidOperationException(
                "NavigationMenuContent must be used within a NavigationMenuRoot component.");
        }

        if (ItemContext == null)
        {
            throw new InvalidOperationException(
                "NavigationMenuContent must be used within a NavigationMenuItem component.");
        }

        Context.OnStateChanged += HandleContextStateChanged;
    }

    protected override void OnParametersSet()
    {
        var currentActive = IsActive;
        
        // Detect closing state
        if (WasActive && !currentActive)
        {
            IsClosing = true;
            // Keep element mounted for animation duration
            _closingTimer?.Dispose();
            _closingTimer = new System.Threading.Timer(_ =>
            {
                IsClosing = false;
                InvokeAsync(StateHasChanged);
            }, null, 300, System.Threading.Timeout.Infinite);
        }
        
        WasActive = currentActive;
    }

    private void HandleContextStateChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    private void HandleMouseLeave()
    {
        Context.ClearActiveItem();
    }

    private void HandleMouseEnter()
    {
        // Keep active when hovering over content - cancel any pending close from trigger
        Context.SetActiveItem(ItemContext.Value);
    }

    private string GetDataState()
    {
        return IsActive ? "open" : "closed";
    }

    private string GetDataMotion()
    {
        if (!IsActive && IsClosing)
        {
            // Closing: motion direction is opposite
            var motionDir = Context.GetMotionDirection(ItemContext.Value);
            return motionDir == "from-end" ? "to-start" : "to-end";
        }
        
        return IsActive ? Context.GetMotionDirection(ItemContext.Value) : "";
    }

    private string GetStyle()
    {
        // When ForceMount is true, keep element mounted but hide with opacity/pointer-events
        // This allows animations to work while keeping content inaccessible when closed
        if (!IsActive && !IsClosing)
        {
            if (ForceMount)
            {
                // Use opacity and pointer-events to hide but keep in DOM for animations
                return "opacity: 0; pointer-events: none; visibility: hidden;";
            }
            return "display: none;";
        }
        
        // During closing animation, keep visible but start hiding
        if (IsClosing && !IsActive)
        {
            return ""; // Let CSS animations handle the transition
        }
        
        return "";
    }

    public void Dispose()
    {
        if (Context != null)
        {
            Context.OnStateChanged -= HandleContextStateChanged;
        }
        _closingTimer?.Dispose();
    }
}
