@namespace BlazorUI.Primitives.Floating
@using BlazorUI.Primitives.Services
@using BlazorUI.Primitives.Constants
@inject IPositioningService PositioningService
@inject IPortalService PortalService
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

@*
    FloatingPortal - Unified infrastructure for floating content.
    Handles ONLY: portal registration, positioning, and lifecycle management.
    Does NOT handle: click-outside, keyboard navigation, or any behavior.

    Use this as the base layer for Select, Popover, DropdownMenu, Tooltip, etc.
*@

@code {
    /// <summary>
    /// The content to render in the floating portal.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Whether the floating content is currently visible.
    /// </summary>
    [Parameter]
    public bool IsOpen { get; set; }

    /// <summary>
    /// The element to position the floating content relative to.
    /// Optional - use X and Y coordinates instead for positioning at arbitrary locations.
    /// </summary>
    [Parameter]
    public ElementReference? AnchorElement { get; set; }

    /// <summary>
    /// X coordinate for positioning (in pixels).
    /// Used when AnchorElement is null for positioning at arbitrary coordinates.
    /// Useful for context menus that need to appear at mouse click location.
    /// </summary>
    [Parameter]
    public double? X { get; set; }

    /// <summary>
    /// Y coordinate for positioning (in pixels).
    /// Used when AnchorElement is null for positioning at arbitrary coordinates.
    /// Useful for context menus that need to appear at mouse click location.
    /// </summary>
    [Parameter]
    public double? Y { get; set; }

    /// <summary>
    /// Unique identifier for this portal instance.
    /// Required to prevent conflicts when multiple floating elements exist.
    /// </summary>
    [Parameter]
    public string PortalId { get; set; } = "";

    /// <summary>
    /// Parent portal ID to append this portal's content to.
    /// When set, this portal's content will be rendered inside the parent's portal
    /// instead of creating a new separate portal. Useful for submenus and nested overlays.
    /// Default is null (creates independent portal).
    /// </summary>
    [Parameter]
    public string? ParentPortalId { get; set; }

    /// <summary>
    /// Preferred side for positioning.
    /// Default is Bottom.
    /// </summary>
    [Parameter]
    public PopoverSide Side { get; set; } = PopoverSide.Bottom;

    /// <summary>
    /// Alignment relative to anchor element.
    /// Default is Center.
    /// </summary>
    [Parameter]
    public PopoverAlign Align { get; set; } = PopoverAlign.Center;

    /// <summary>
    /// Offset distance from the anchor element in pixels.
    /// Default is 4.
    /// </summary>
    [Parameter]
    public int Offset { get; set; } = 4;

    /// <summary>
    /// Whether to match the floating content width to the anchor element width.
    /// Default is false.
    /// </summary>
    [Parameter]
    public bool MatchAnchorWidth { get; set; } = false;

    /// <summary>
    /// CSS positioning strategy: "absolute" or "fixed".
    /// Use "fixed" for dropdowns that need to escape stacking contexts.
    /// Default is "absolute".
    /// </summary>
    [Parameter]
    public string Strategy { get; set; } = "absolute";

    /// <summary>
    /// CSS z-index value for the floating content.
    /// Default is 60 (PopoverContent level).
    /// Use ZIndexLevels constants for proper layering:
    /// - DialogOverlay: 40
    /// - DialogContent: 50
    /// - PopoverContent: 60 (default for dropdowns/menus/selects)
    /// - TooltipContent: 70
    /// </summary>
    [Parameter]
    public int ZIndex { get; set; } = ZIndexLevels.PopoverContent;

    /// <summary>
    /// Whether to keep the portal mounted when closed.
    /// When true, portal stays registered and content stays in DOM (but hidden).
    /// Useful for maintaining state or avoiding re-registration overhead.
    /// Default is false.
    /// </summary>
    [Parameter]
    public bool ForceMount { get; set; } = false;

    /// <summary>
    /// Event callback invoked when the floating content is positioned and visible.
    /// Use this to set up keyboard navigation, focus management, etc.
    /// </summary>
    [Parameter]
    public EventCallback OnReady { get; set; }

    /// <summary>
    /// Additional attributes to apply to the portal container.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    private IAsyncDisposable? _positioningCleanup;
    private bool _isInitialized = false;
    private bool _isPositioned = false;
    private bool _previousIsOpen = false;
    private ElementReference _portalContentRef;
    private TaskCompletionSource<bool>? _portalReadyTcs;

    // Store computed position so it survives Blazor re-renders
    private double _positionLeft = 0;
    private double _positionTop = 0;

    protected override void OnInitialized()
    {
        if (string.IsNullOrEmpty(PortalId))
        {
            throw new InvalidOperationException(
                "FloatingPortal requires a PortalId to be specified. " +
                "Each floating element must have a unique identifier.");
        }

        // Subscribe to portal ready events for synchronization
        PortalService.OnPortalRendered += HandlePortalRendered;
    }

    private void HandlePortalRendered(string portalId)
    {
        if (portalId == PortalId)
        {
            _portalReadyTcs?.TrySetResult(true);
        }
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        // Refresh portal content when parameters change and portal is open
        if (_isInitialized && IsOpen && !string.IsNullOrEmpty(PortalId))
        {
            PortalService.RefreshPortal(PortalId);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Setup when opening OR when ForceMount is enabled and not yet initialized
        if ((IsOpen || ForceMount) && !_isInitialized)
        {
            _isInitialized = true;
            _isPositioned = false;

            // Register content through portal - this triggers PortalHost to re-render
            if (!string.IsNullOrEmpty(ParentPortalId))
            {
                // Child: Append to parent's portal scope
                PortalService.AppendToPortal(ParentPortalId, PortalId, RenderPortalContent());
                
                // Children don't need to wait for notification - they're part of parent's render cycle
                // Just yield to ensure the composite render completes
                await Task.Yield();
            }
            else
            {
                // Root: Create new independent portal and wait for PortalHost notification
                _portalReadyTcs = new TaskCompletionSource<bool>();
                
                PortalService.RegisterPortal(PortalId, PortalCategory.Overlay, RenderPortalContent());

                // Wait for PortalHost to signal it's done rendering our portal
                // Use timeout to prevent hanging if something goes wrong
                var timeoutTask = Task.Delay(500);
                var completedTask = await Task.WhenAny(_portalReadyTcs.Task, timeoutTask);

                if (completedTask == timeoutTask)
                {
                    Console.WriteLine($"Warning: Portal {PortalId} render timeout");
                }

                // Yield to ensure any pending re-renders complete and _portalContentRef is up-to-date
                await Task.Yield();
            }

            // Check if still open OR ForceMount (user might have closed during wait)
            if (!IsOpen && !ForceMount)
                return;

            // NOW _portalContentRef is guaranteed to be valid!
            // Only position if actually opening (not just ForceMount closed)
            if (IsOpen)
            {
                await SetupAsync();
            }
            
            // Initialize previous state tracking
            _previousIsOpen = IsOpen;
        }
        // Only cleanup if not ForceMount and closed
        else if (!IsOpen && _isInitialized && !ForceMount)
        {
            await CleanupAsync();
        }
        // Update visibility ONLY when IsOpen actually changes (ForceMount)
        else if (_isInitialized && ForceMount && IsOpen != _previousIsOpen)
        {
            await UpdateVisibilityAsync();
            
            // Update tracking AFTER visibility change completes
            _previousIsOpen = IsOpen;
        }
    }

    /// <summary>
    /// Sets up positioning after portal has rendered.
    /// </summary>
    private async Task SetupAsync()
    {
        try
        {
            // Set up positioning and make visible via JS
            await SetupPositioningAsync();

            // Mark as positioned for any future Blazor re-renders
            _isPositioned = true;

            // Notify consumers that content is ready (for focus management, keyboard handlers, etc.)
            if (OnReady.HasDelegate && IsOpen)
            {
                await OnReady.InvokeAsync();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"FloatingPortal setup failed: {ex.Message}");
        }
    }

    /// <summary>
    /// Updates visibility when ForceMount is enabled and IsOpen changes.
    /// </summary>
    private async Task UpdateVisibilityAsync()
    {
        try
        {
            if (IsOpen)
            {
                // If opening for first time with ForceMount, run full setup
                if (!_isPositioned)
                {
                    await SetupAsync();
                }
                else
                {
                    // Already positioned, just show
                    await PositioningService.ShowFloatingAsync(_portalContentRef);
                    
                    // CRITICAL: Trigger OnReady for focus management and keyboard nav
                    if (OnReady.HasDelegate)
                    {
                        await OnReady.InvokeAsync();
                    }
                }
            }
            else
            {
                // Hide using dedicated visibility function (ForceMount keeps it mounted)
                await PositioningService.HideFloatingAsync(_portalContentRef);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"FloatingPortal visibility update failed: {ex.Message}");
        }
    }

    private RenderFragment RenderPortalContent() => __builder =>
    {
        <div @ref="_portalContentRef"
             @attributes="GetAttributesWithoutStyle()"
             data-portal-content="true"
             style="@GetMergedStyle()">
            @ChildContent
        </div>
    };

    private async Task SetupPositioningAsync()
    {
        // Support two positioning modes:
        // 1. Anchor-based: Position relative to an element (dropdowns, popovers, tooltips)
        // 2. Coordinate-based: Position at specific X/Y coordinates (context menus)
        
        if (X.HasValue && Y.HasValue)
        {
            // Coordinate-based positioning for context menus
            await SetupCoordinatePositioningAsync(X.Value, Y.Value);
        }
        else if (AnchorElement.HasValue)
        {
            // Anchor-based positioning for dropdowns/popovers
            await SetupAnchorPositioningAsync(AnchorElement.Value);
        }
        else
        {
            Console.WriteLine("Warning: FloatingPortal - Neither AnchorElement nor X/Y coordinates provided");
        }
    }

    private async Task SetupCoordinatePositioningAsync(double x, double y)
    {
        try
        {
            // Position at exact coordinates with viewport boundary detection
            var position = await PositioningService.ApplyCoordinatePositionAsync(
                _portalContentRef,
                x,
                y,
                padding: Offset,
                makeVisible: true);

            // Store final position (may be adjusted by viewport boundaries)
            _positionLeft = position.X;
            _positionTop = position.Y;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up coordinate positioning: {ex.Message}");
        }
    }

    private async Task SetupAnchorPositioningAsync(ElementReference anchor)
    {
        try
        {
            // Construct placement string from Side and Align
            var placement = Align == PopoverAlign.Center ? Side.ToValue() : $"{Side.ToValue()}-{Align.ToValue()}";

            var options = new PositioningOptions
            {
                Placement = placement,
                Offset = Offset,
                MatchReferenceWidth = MatchAnchorWidth,
                Strategy = Strategy,
                Flip = true,  // Enable flip to opposite side when not enough space
                Shift = true  // Enable shift to keep in viewport
            };

            // Compute position using the portal content ref
            var position = await PositioningService.ComputePositionAsync(
                anchor,
                _portalContentRef,
                options);

            // Store position in Blazor state so it survives re-renders
            _positionLeft = position.X;
            _positionTop = position.Y;

            // Apply position via JS for initial display
            await PositioningService.ApplyPositionAsync(_portalContentRef, position, makeVisible: true);

            // Set up auto-update for dynamic positioning (scroll, resize)
            _positioningCleanup = await PositioningService.AutoUpdateAsync(
                anchor,
                _portalContentRef,
                options);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up anchor positioning: {ex.Message}");
        }
    }

    /// <summary>
    /// Gets the initial inline style for the portal content.
    /// </summary>
    private string GetInitialStyle()
    {
        if (!_isPositioned)
        {
            // Use position: fixed with off-screen coordinates to prevent:
            // 1. Flash at wrong position (fixed doesn't depend on parent context)
            // 2. Scroll jump (visibility: hidden prevents browser from scrolling to element)
            // 3. Layout interference (pointer-events: none prevents interaction)
            return $"position: fixed; z-index: {ZIndex}; top: -9999px; left: -9999px; visibility: hidden; opacity: 0; pointer-events: none;";
        }

        // After positioning, include stored position so it survives Blazor re-renders
        // This prevents the content from "closing" when parent components re-render
        return $"position: {Strategy}; z-index: {ZIndex}; left: {_positionLeft}px; top: {_positionTop}px; opacity: 1; visibility: visible;";
    }

    private string GetMergedStyle()
    {
        var baseStyle = GetInitialStyle();

        if (AdditionalAttributes != null && AdditionalAttributes.TryGetValue("style", out var userStyle))
        {
            return $"{userStyle}; {baseStyle}";
        }

        return baseStyle;
    }

    private Dictionary<string, object>? GetAttributesWithoutStyle()
    {
        if (AdditionalAttributes == null) return null;

        var attributes = new Dictionary<string, object>(AdditionalAttributes);
        attributes.Remove("style");

        return attributes.Count > 0 ? attributes : null;
    }

    private async Task CleanupAsync()
    {
        // Dispose positioning auto-update
        if (_positioningCleanup != null)
        {
            await _positioningCleanup.DisposeAsync();
            _positioningCleanup = null;
        }

        // Unregister portal when content closes
        if (!string.IsNullOrEmpty(PortalId))
        {
            if (!string.IsNullOrEmpty(ParentPortalId))
            {
                // Child: Remove from parent's scope
                PortalService.RemoveFromPortal(ParentPortalId, PortalId);
            }
            else
            {
                // Root: Unregister portal entirely
                PortalService.UnregisterPortal(PortalId);
            }
        }

        _isInitialized = false;
        _isPositioned = false;
    }

    public async ValueTask DisposeAsync()
    {
        // Unsubscribe from portal ready events
        PortalService.OnPortalRendered -= HandlePortalRendered;

        await CleanupAsync();
    }
}
