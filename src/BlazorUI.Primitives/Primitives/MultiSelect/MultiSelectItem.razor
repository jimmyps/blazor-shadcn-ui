@namespace BlazorUI.Primitives.MultiSelect
@implements IDisposable

@* MultiSelectItem primitive - headless selectable item with checkbox behavior *@
@if (_isVisible)
{
    <div @ref="_itemElement"
         id="@_itemId"
         role="option"
         aria-selected="@(_isSelected ? "true" : "false")"
         aria-disabled="@(Disabled ? "true" : "false")"
         data-focused="@_isFocused"
         data-disabled="@Disabled"
         data-selected="@_isSelected"
         @onclick="HandleClick"
         @onclick:stopPropagation="true"
         @onmouseenter="HandleMouseEnter"
         @attributes="AdditionalAttributes">
        @ChildContent
    </div>
}

@code {
    [CascadingParameter]
    public MultiSelectContext Context { get; set; } = null!;

    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// The value associated with this item.
    /// </summary>
    [Parameter]
    public string? Value { get; set; }

    /// <summary>
    /// The text used for search filtering.
    /// If not provided, uses the DisplayText or Value.
    /// </summary>
    [Parameter]
    public string? SearchText { get; set; }

    /// <summary>
    /// The display text for this item.
    /// If not provided, uses the Value.
    /// </summary>
    [Parameter]
    public string? DisplayText { get; set; }

    /// <summary>
    /// Whether this item is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Callback invoked when this item is toggled.
    /// </summary>
    [Parameter]
    public EventCallback OnToggle { get; set; }

    /// <summary>
    /// Additional attributes to apply to the item element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    private ElementReference _itemElement;
    private int _index = -1;
    private string _itemId = string.Empty;
    private bool _isFocused;
    private bool _isVisible = true;
    private bool _isSelected;

    /// <summary>
    /// Gets whether this item is currently selected.
    /// </summary>
    public bool IsSelected => _isSelected;

    /// <summary>
    /// Gets whether this item is currently focused.
    /// </summary>
    public bool IsFocused => _isFocused;

    protected override void OnInitialized()
    {
        if (Context == null)
        {
            throw new InvalidOperationException($"{nameof(MultiSelectItem)} must be used within a {nameof(MultiSelect)} component.");
        }

        // Register with context
        _index = Context.RegisterItem(
            value: Value,
            searchText: SearchText ?? DisplayText ?? Value,
            displayText: DisplayText ?? Value,
            disabled: Disabled,
            onToggle: OnToggle
        );

        _itemId = Context.GetItemId(_index);

        // Subscribe to context state changes
        Context.OnStateChanged += HandleContextStateChanged;

        // Initial state
        UpdateState();
    }

    private async Task HandleClick()
    {
        if (Disabled) return;

        // Toggle selection
        Context.ToggleValue(Value);

        if (OnToggle.HasDelegate)
        {
            await OnToggle.InvokeAsync();
        }
    }

    private void HandleMouseEnter()
    {
        if (Disabled) return;

        // Set focus when mouse enters (for keyboard-mouse mixed navigation)
        var filteredItems = Context.GetFilteredItems();
        var thisItem = Context.GetItemByIndex(_index);

        if (thisItem != null)
        {
            var indexInFiltered = filteredItems.IndexOf(thisItem);
            if (indexInFiltered >= 0)
            {
                Context.SetFocusedIndex(indexInFiltered);
            }
        }
    }

    private void HandleContextStateChanged()
    {
        UpdateState();
        StateHasChanged();
    }

    private void UpdateState()
    {
        // Update selected state
        _isSelected = Context.IsSelected(Value);

        // Update focused state by finding this item's position in filtered list
        var filteredItems = Context.GetFilteredItems();
        var thisItem = Context.GetItemByIndex(_index);

        if (thisItem != null)
        {
            // Find this item's position in the filtered list
            var indexInFiltered = filteredItems.IndexOf(thisItem);
            _isFocused = indexInFiltered >= 0 && Context.FocusedIndex == indexInFiltered;
        }
        else
        {
            _isFocused = false;
        }

        // Update visibility based on filter
        UpdateVisibility();
    }

    private void UpdateVisibility()
    {
        var thisItem = Context.GetItemByIndex(_index);
        if (thisItem == null)
        {
            _isVisible = false;
            return;
        }

        // Apply filter directly to this item
        if (string.IsNullOrWhiteSpace(Context.SearchQuery))
        {
            _isVisible = true;
        }
        else if (Context.FilterFunction != null)
        {
            _isVisible = Context.FilterFunction(thisItem, Context.SearchQuery);
        }
        else
        {
            _isVisible = thisItem.SearchText?.Contains(Context.SearchQuery, StringComparison.OrdinalIgnoreCase) ?? false;
        }
    }

    public void Dispose()
    {
        if (Context != null && _index >= 0)
        {
            Context.UnregisterItem(_index);
            Context.OnStateChanged -= HandleContextStateChanged;
        }
    }
}
