@namespace BlazorUI.Primitives.MultiSelect
@implements IAsyncDisposable
@inject IJSRuntime JS

@* MultiSelect root component - headless, unstyled behavior only *@
<CascadingValue Value="@_context" IsFixed="false">
    <div @attributes="AdditionalAttributes">
        @ChildContent
    </div>
</CascadingValue>

@code {
    private MultiSelectContext _context = new();
    private UseControllableState<IEnumerable<string>?> _valuesState = null!;
    private UseControllableState<bool> _openState = null!;

    /// <summary>
    /// The child content to render within the multiselect context.
    /// Typically includes MultiSelectTrigger and MultiSelectContent.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Additional attributes to apply to the root element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// The currently selected values (controlled mode).
    /// When null, the multiselect manages its own state (uncontrolled mode).
    /// </summary>
    [Parameter]
    public IEnumerable<string>? Values { get; set; }

    /// <summary>
    /// Event callback invoked when the selected values change.
    /// Use with @bind-Values for two-way binding.
    /// </summary>
    [Parameter]
    public EventCallback<IEnumerable<string>?> ValuesChanged { get; set; }

    /// <summary>
    /// Default selected values when in uncontrolled mode.
    /// </summary>
    [Parameter]
    public IEnumerable<string>? DefaultValues { get; set; }

    /// <summary>
    /// Event callback invoked when the selected values change.
    /// Receives the new values as a parameter.
    /// </summary>
    [Parameter]
    public EventCallback<IEnumerable<string>?> OnValuesChange { get; set; }

    /// <summary>
    /// Whether the dropdown is open (controlled mode).
    /// </summary>
    [Parameter]
    public bool? Open { get; set; }

    /// <summary>
    /// Event callback invoked when the open state changes.
    /// </summary>
    [Parameter]
    public EventCallback<bool> OpenChanged { get; set; }

    /// <summary>
    /// Default open state when in uncontrolled mode.
    /// </summary>
    [Parameter]
    public bool DefaultOpen { get; set; } = false;

    /// <summary>
    /// Event callback invoked when the open state changes.
    /// </summary>
    [Parameter]
    public EventCallback<bool> OnOpenChange { get; set; }

    /// <summary>
    /// Whether the multiselect is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Maximum number of tags to display before showing "+N more".
    /// </summary>
    [Parameter]
    public int MaxDisplayTags { get; set; } = 3;

    /// <summary>
    /// Custom filter function for items.
    /// If provided, overrides the default Contains matching.
    /// </summary>
    [Parameter]
    public Func<MultiSelectItemMetadata, string, bool>? FilterFunction { get; set; }

    protected override void OnInitialized()
    {
        // Initialize controllable state for values
        _valuesState = new UseControllableState<IEnumerable<string>?>(DefaultValues)
        {
            ControlledValue = Values,
            OnValueChanged = ValuesChanged,
            IsControlled = ValuesChanged.HasDelegate
        };

        // Initialize controllable state for open
        _openState = new UseControllableState<bool>(DefaultOpen)
        {
            ControlledValue = Open ?? DefaultOpen,
            OnValueChanged = OpenChanged,
            IsControlled = OpenChanged.HasDelegate && Open.HasValue
        };

        // Sync initial values to context
        if (_valuesState.Value != null)
        {
            _context.SetSelectedValues(_valuesState.Value);
        }
        _context.State.IsOpen = _openState.Value;
        _context.State.Disabled = Disabled;
        _context.FilterFunction = FilterFunction;
        _context.MaxDisplayTags = MaxDisplayTags;

        // Subscribe to context values changes
        _context.OnValuesChange = async (newValues) =>
        {
            await _valuesState.SetValueAsync(newValues);

            if (OnValuesChange.HasDelegate)
            {
                await OnValuesChange.InvokeAsync(newValues);
            }

            StateHasChanged();
        };

        // Subscribe to context open state changes
        _context.OnOpenChange = async (isOpen) =>
        {
            await _openState.SetValueAsync(isOpen);

            if (OnOpenChange.HasDelegate)
            {
                await OnOpenChange.InvokeAsync(isOpen);
            }

            StateHasChanged();
        };

        // Subscribe to context state changes
        _context.OnStateChanged += HandleContextStateChanged;
    }

    protected override void OnParametersSet()
    {
        // Update disabled state
        if (_context.Disabled != Disabled)
        {
            _context.SetDisabled(Disabled);
        }

        // Update filter function
        if (_context.FilterFunction != FilterFunction)
        {
            _context.FilterFunction = FilterFunction;
        }

        // Update max display tags
        if (_context.MaxDisplayTags != MaxDisplayTags)
        {
            _context.MaxDisplayTags = MaxDisplayTags;
        }

        // Update controlled values if changed
        if (_valuesState.IsControlled && Values != null)
        {
            _valuesState.ControlledValue = Values;
            var currentValues = _context.SelectedValues;
            var newValues = Values.ToList();

            // Only update if actually different
            if (!currentValues.SequenceEqual(newValues))
            {
                _context.SetSelectedValues(newValues);
            }
        }

        // Update controlled open state if changed
        if (_openState.IsControlled && Open.HasValue)
        {
            _openState.ControlledValue = Open.Value;
            if (_context.IsOpen != Open.Value)
            {
                if (Open.Value)
                {
                    _context.Open();
                }
                else
                {
                    _context.Close();
                }
            }
        }
    }

    private void HandleContextStateChanged()
    {
        // When context state changes, notify parent if Values is being controlled
        if (ValuesChanged.HasDelegate)
        {
            var newValues = _context.SelectedValues;
            _ = ValuesChanged.InvokeAsync(newValues);
        }

        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        _context.OnStateChanged -= HandleContextStateChanged;
        await Task.CompletedTask;
    }
}
