@namespace BlazorUI.Primitives.ContextMenu
@inject IJSRuntime JSRuntime
@implements IContextMenuItem
@implements IDisposable

@* ContextMenuItem - an individual menu action *@
<div @ref="_itemRef"
     role="menuitem"
     tabindex="-1"
     @onclick="HandleClick"
     @onkeydown="HandleKeyDown"
     @onmouseenter="HandleMouseEnter"
     @attributes="AdditionalAttributes"
     aria-disabled="@Disabled.ToString().ToLowerInvariant()"
     data-disabled="@(Disabled ? "true" : null)">
    @ChildContent
</div>

@code {
    [CascadingParameter]
    private ContextMenuContext Context { get; set; } = null!;

    [CascadingParameter]
    private ContextMenuContent? ContentContainer { get; set; }
    
    [CascadingParameter(Name = "ParentSubContext")]
    private ContextMenuSubContext? ParentSubContext { get; set; }
    
    [CascadingParameter]
    private ContextMenuSubContent? SubContentContext { get; set; }

    private ElementReference _itemRef;
    private IJSObjectReference? _keyboardNavModule;
    private bool _keyboardNavModuleLoaded = false;

    /// <summary>
    /// The child content to render within the item.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Whether the item is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; } = false;

    /// <summary>
    /// Event callback invoked when the item is clicked.
    /// </summary>
    [Parameter]
    public EventCallback OnClick { get; set; }

    /// <summary>
    /// Additional attributes to apply to the item element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    bool IContextMenuItem.Disabled => Disabled;

    protected override void OnInitialized()
    {
        if (Context == null)
        {
            throw new InvalidOperationException(
                "ContextMenuItem must be used within a ContextMenuRoot component.");
        }

        // Register this item with the appropriate content for keyboard navigation
        // If we're inside a submenu, register with the submenu content
        // Otherwise, register with the root menu content
        if (SubContentContext != null)
        {
            SubContentContext.RegisterItem(this);
        }
        else
        {
            ContentContainer?.RegisterItem(this);
        }
    }

    private async Task HandleClick()
    {
        if (Disabled) return;

        if (OnClick.HasDelegate)
        {
            await OnClick.InvokeAsync();
        }

        Context.Close();
    }

    private async Task HandleKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Enter" || args.Key == " ")
        {
            await HandleClick();
        }
    }

    private async void HandleMouseEnter(MouseEventArgs args)
    {
        // Track if there was an active submenu that we're closing
        bool hadActiveSubmenu = false;
        
        // Close any active submenu when hovering over this item
        // If we're inside a submenu (ParentSubContext exists), close nested submenus of that parent
        // If we're at root level, close any active submenu from the root context
        if (ParentSubContext != null)
        {
            // We're inside a submenu - close any nested submenus
            hadActiveSubmenu = ParentSubContext.ActiveSubMenu != null;
            ParentSubContext.CloseActiveSubMenu();
        }
        else
        {
            // We're at root level - close active submenu from root context
            hadActiveSubmenu = Context?.ActiveSubMenu != null;
            Context?.CloseActiveSubMenu();
        }
        
        // Restore focus to the menu container (not the item) when we closed a submenu
        // This enables keyboard navigation without showing focus ring on a specific item
        if (hadActiveSubmenu)
        {
            // Focus the content container - if in submenu, focus SubContentContext, else ContentContainer
            if (SubContentContext != null)
            {
                await SubContentContext.FocusContainerAsync();
            }
            else if (ContentContainer != null)
            {
                await ContentContainer.FocusContainerAsync();
            }
        }
    }

    public async Task FocusAsync()
    {
        await FocusElementAsync(_itemRef, "context menu item");
    }

    /// <summary>
    /// Focuses an element using JavaScript with fallback to C# focus.
    /// Lazy-loads the keyboard-nav module on first use.
    /// </summary>
    private async Task<bool> FocusElementAsync(ElementReference element, string elementName = "element")
    {
        // Lazy-load keyboard nav module on first focus attempt
        if (!_keyboardNavModuleLoaded)
        {
            try
            {
                _keyboardNavModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "import", "./_content/NeoBlazorUI.Primitives/js/primitives/keyboard-nav.js");
                _keyboardNavModuleLoaded = true;
            }
            catch
            {
                // Module load failed, will use C# fallback
            }
        }

        // Try JavaScript focus first
        if (_keyboardNavModule != null)
        {
            try
            {
                var focused = await _keyboardNavModule.InvokeAsync<bool>("focusElement", element);
                if (focused)
                {
                    return true;
                }
            }
            catch
            {
                // JS focus failed, will try C# fallback
            }
        }

        // Fallback to C# focus
        try
        {
            await element.FocusAsync();
            return true;
        }
        catch
        {
            return false;
        }
    }

    public void Dispose()
    {
        if (SubContentContext != null)
        {
            SubContentContext.UnregisterItem(this);
        }
        else
        {
            ContentContainer?.UnregisterItem(this);
        }

        // Cleanup keyboard nav module
        if (_keyboardNavModule != null)
        {
            try
            {
                _keyboardNavModule.DisposeAsync();
            }
            catch { }
            _keyboardNavModule = null;
        }
    }
}
