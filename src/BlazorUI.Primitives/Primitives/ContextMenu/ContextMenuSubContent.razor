@namespace BlazorUI.Primitives.ContextMenu
@using BlazorUI.Primitives.Floating
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

@*
    ContextMenuSubContent - the content panel for a submenu
    Uses FloatingPortal for positioning infrastructure.
*@

<FloatingPortal IsOpen="@SubContext.IsOpen"
                AnchorElement="@SubContext.TriggerElement"
                PortalId="@_portalId"
                ParentPortalId="@GetParentPortalId()"
                Side="PopoverSide.Right"
                Align="PopoverAlign.Start"
                Offset="@Offset"
                Strategy="PositioningStrategy.Fixed"
                ZIndex="@ZIndex"
                OnReady="@HandleFloatingReady">
    @RenderSubMenuContent()
</FloatingPortal>

@code {
    [CascadingParameter]
    private ContextMenuContext? MenuContext { get; set; }

    [CascadingParameter]
    private ContextMenuSubContext SubContext { get; set; } = null!;

    [CascadingParameter(Name = "ParentSubContext")]
    private ContextMenuSubContext? ParentSubContext { get; set; }

    private ElementReference _contentRef;
    private string _portalId = "";

    // Track menu items for keyboard navigation
    private readonly List<IContextMenuItem> _menuItems = new();
    private int _focusedIndex = -1;

    /// <summary>
    /// The content to render inside the submenu.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Additional attributes to apply to the content container.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Whether pressing Escape should close the submenu.
    /// Default is true.
    /// </summary>
    [Parameter]
    public bool CloseOnEscape { get; set; } = true;

    /// <summary>
    /// Offset distance from the trigger element in pixels.
    /// Default is -4 (slight overlap with parent).
    /// </summary>
    [Parameter]
    public int Offset { get; set; } = -4;

    /// <summary>
    /// Z-index value for the submenu content.
    /// Default is 50.
    /// </summary>
    [Parameter]
    public int ZIndex { get; set; } = 50;

    protected override void OnInitialized()
    {
        if (SubContext == null)
        {
            throw new InvalidOperationException(
                "ContextMenuSubContent must be used within a ContextMenuSub component.");
        }

        _portalId = $"contextmenu-submenu-{SubContext.GetHashCode()}";
        SubContext.OnStateChanged += HandleContextStateChanged;
    }

    /// <summary>
    /// Gets the parent portal ID for hierarchical portal nesting.
    /// ALL children append to the root portal, regardless of nesting depth.
    /// This ensures only one portal exists for the entire menu hierarchy.
    /// </summary>
    private string? GetParentPortalId()
    {
        // Always append to root portal, even if this is a nested submenu
        // The parent-child UI relationship is maintained through composite rendering,
        // but all children are siblings in the portal scope
        return MenuContext != null ? $"contextmenu-portal-{MenuContext.ContentId}" : null;
    }

    private RenderFragment RenderSubMenuContent() => __builder =>
    {
        <div @ref="_contentRef"
             role="menu"
             tabindex="-1"
             @onkeydown="HandleKeyDown"
             @onkeydown:stopPropagation="true"
             @onmouseleave="HandleMouseLeave"
             @attributes="AdditionalAttributes"
             data-state="open">
            @* Re-cascade MenuContext since FloatingPortal breaks cascading chain *@
            <CascadingValue Value="MenuContext" IsFixed="false">
                <CascadingValue Value="@this" IsFixed="false">
                    <CascadingValue Value="@SubContext" Name="ParentSubContext" IsFixed="false">
                        @ChildContent
                    </CascadingValue>
                </CascadingValue>
            </CascadingValue>
        </div>
    };

    private async Task HandleFloatingReady()
    {
        // Focus the submenu content
        try
        {
            await _contentRef.FocusAsync();
        }
        catch
        {
            // Focus may fail
        }
    }

    private void HandleContextStateChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    private async void HandleKeyDown(KeyboardEventArgs args)
    {
        switch (args.Key)
        {
            case "Escape":
                if (CloseOnEscape)
                {
                    // Close ALL menus including root when Escape is pressed
                    MenuContext?.Close();
                }
                break;

            case "ArrowLeft":
                // Close submenu and return focus to trigger
                SubContext.Close();
                // Restore focus to the trigger element
                if (SubContext.TriggerElement.HasValue)
                {
                    try
                    {
                        await SubContext.TriggerElement.Value.FocusAsync();
                    }
                    catch
                    {
                        // Focus may fail
                    }
                }
                break;

            case "ArrowDown":
                await FocusNextItem();
                break;

            case "ArrowUp":
                await FocusPreviousItem();
                break;
        }
    }

    private async Task FocusNextItem()
    {
        if (_menuItems.Count == 0) return;

        var enabledItems = _menuItems.Where(item => !item.Disabled).ToList();
        if (enabledItems.Count == 0) return;

        int nextIndex;
        if (_focusedIndex == -1)
        {
            nextIndex = 0;
        }
        else
        {
            var currentEnabledIndex = GetEnabledItemIndex(enabledItems, _focusedIndex);
            if (currentEnabledIndex == -1)
            {
                nextIndex = 0;
            }
            else if (currentEnabledIndex >= enabledItems.Count - 1)
            {
                nextIndex = 0; // Wrap to first
            }
            else
            {
                nextIndex = currentEnabledIndex + 1;
            }
        }

        await FocusItem(enabledItems, nextIndex);
    }

    private async Task FocusPreviousItem()
    {
        if (_menuItems.Count == 0) return;

        var enabledItems = _menuItems.Where(item => !item.Disabled).ToList();
        if (enabledItems.Count == 0) return;

        int prevIndex;
        if (_focusedIndex == -1)
        {
            prevIndex = enabledItems.Count - 1;
        }
        else
        {
            var currentEnabledIndex = GetEnabledItemIndex(enabledItems, _focusedIndex);
            if (currentEnabledIndex == -1)
            {
                prevIndex = enabledItems.Count - 1;
            }
            else if (currentEnabledIndex <= 0)
            {
                prevIndex = enabledItems.Count - 1; // Wrap to last
            }
            else
            {
                prevIndex = currentEnabledIndex - 1;
            }
        }

        await FocusItem(enabledItems, prevIndex);
    }

    private int GetEnabledItemIndex(List<IContextMenuItem> enabledItems, int absoluteIndex)
    {
        if (absoluteIndex < 0 || absoluteIndex >= _menuItems.Count) return -1;
        var currentItem = _menuItems[absoluteIndex];
        return enabledItems.IndexOf(currentItem);
    }

    private async Task FocusItem(List<IContextMenuItem> enabledItems, int enabledIndex)
    {
        if (enabledIndex < 0 || enabledIndex >= enabledItems.Count) return;
        var item = enabledItems[enabledIndex];
        _focusedIndex = _menuItems.IndexOf(item);
        await item.FocusAsync();
    }

    private void HandleMouseLeave(MouseEventArgs args)
    {
        // Don't close on mouse leave - closing is handled by:
        // 1. Hovering sibling menu items (which call CloseActiveSubMenu)
        // 2. Keyboard navigation (ArrowLeft, Escape)
        // This prevents the submenu from closing when moving mouse to its own items
    }

    public async ValueTask DisposeAsync()
    {
        SubContext.OnStateChanged -= HandleContextStateChanged;
    }

    /// <summary>
    /// Registers a menu item for keyboard navigation.
    /// </summary>
    internal void RegisterItem(IContextMenuItem item)
    {
        if (!_menuItems.Contains(item))
        {
            _menuItems.Add(item);
        }
    }

    /// <summary>
    /// Unregisters a menu item.
    /// </summary>
    internal void UnregisterItem(IContextMenuItem item)
    {
        _menuItems.Remove(item);
    }

    /// <summary>
    /// Focuses the content container for keyboard navigation.
    /// </summary>
    internal async Task FocusContainerAsync()
    {
        try
        {
            await _contentRef.FocusAsync();
            _focusedIndex = -1;
        }
        catch
        {
            // Focus may fail
        }
    }
}
