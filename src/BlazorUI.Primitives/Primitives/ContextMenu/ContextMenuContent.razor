@namespace BlazorUI.Primitives.ContextMenu
@using BlazorUI.Primitives.Constants
@using BlazorUI.Primitives.Floating
@using BlazorUI.Primitives.Services
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

@*
    ContextMenuContent - the dropdown content for the context menu
    Uses FloatingPortal with X/Y coordinates for positioning at mouse location.
*@

@if (Context.IsOpen)
{
    @* Overlay rendered separately, outside the FloatingPortal *@
    <div class="@OverlayClass"
         style="@GetOverlayStyle()"
         @oncontextmenu="HandleOverlayClose"
         @oncontextmenu:preventDefault="true"
         data-state="open">
    </div>

    <FloatingPortal IsOpen="true"
                    X="@Context.X"
                    Y="@Context.Y"
                    PortalId="@_portalId"
                    Offset="@ViewportPadding"
                    Strategy="fixed"
                    ZIndex="@ZIndex"
                    OnReady="@HandleFloatingReady">
        @RenderContextMenuContent()
    </FloatingPortal>
}

@code {
[CascadingParameter]
private ContextMenuContext Context { get; set; } = null!;

private ElementReference _contentRef;
private IJSObjectReference? _clickOutsideModule;
private IJSObjectReference? _clickOutsideCleanup;
private IJSObjectReference? _keyboardNavModule;
private IJSObjectReference? _keyboardNavCleanup;
private IJSObjectReference? _scrollLockModule;
private IJSObjectReference? _scrollLockCleanup;
private DotNetObjectReference<ContextMenuContent>? _dotNetRef;
private string _portalId = "";

// Track menu items for keyboard navigation (consistent with DropdownMenu/Menubar pattern)
private readonly List<IContextMenuItem> _menuItems = new();
private int _focusedItemIndex = -1;

    /// <summary>
    /// The content to render inside the menu.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Additional attributes to apply to the content container.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Whether pressing Escape should close the menu.
    /// </summary>
    [Parameter]
    public bool CloseOnEscape { get; set; } = true;

    /// <summary>
    /// Whether clicking outside should close the menu.
    /// </summary>
    [Parameter]
    public bool CloseOnClickOutside { get; set; } = true;

    /// <summary>
    /// Z-index value for the menu content.
    /// </summary>
    [Parameter]
    public int ZIndex { get; set; } = ZIndexLevels.PopoverContent;

    /// <summary>
    /// Whether to enable keyboard loop navigation.
    /// Default is true.
    /// </summary>
    [Parameter]
    public bool Loop { get; set; } = true;

    /// <summary>
    /// CSS class for the overlay element.
    /// </summary>
    [Parameter]
    public string? OverlayClass { get; set; }

    /// <summary>
    /// Whether to lock body scroll when menu is open.
    /// Default is false (context menus typically don't lock scroll).
    /// </summary>
    [Parameter]
    public bool LockScroll { get; set; } = false;

    /// <summary>
    /// Padding from viewport edges when repositioning the menu.
    /// Default is 8 pixels.
    /// </summary>
    [Parameter]
    public int ViewportPadding { get; set; } = 8;

    protected override void OnInitialized()
    {
        if (Context == null)
        {
            throw new InvalidOperationException(
                "ContextMenuContent must be used within a ContextMenuRoot component.");
        }

        _portalId = $"contextmenu-portal-{Context.ContentId}";
        Context.OnStateChanged += HandleContextStateChanged;
    }

    private void HandleOverlayClick(MouseEventArgs e)
    {
        if (CloseOnClickOutside)
        {
            Context.Close();
        }
    }

    private void HandleOverlayClose(MouseEventArgs e)
    {
        if (Context != null)
        {
            Context.Close();
        }
    }

    private async Task HandleFloatingReady()
    {
        // FloatingPortal has positioned the content, now set up behavior
        if (CloseOnClickOutside)
        {
            await SetupClickOutsideAsync();
        }

        // Set up keyboard navigation
        await SetupKeyboardNavAsync();

        // Lock body scroll when menu is open (if enabled)
        if (LockScroll)
        {
            await SetupScrollLockAsync();
        }

        // Focus the content for keyboard navigation
        try
        {
            await _contentRef.FocusAsync();
        }
        catch
        {
            // Focus may fail in some scenarios
        }
    }

    private RenderFragment RenderContextMenuContent() => __builder =>
    {
        <div @ref="_contentRef"
             id="@Context.ContentId"
             role="menu"
             tabindex="-1"
             @onkeydown="HandleKeyDown"
             @attributes="AdditionalAttributes"
             aria-labelledby="@Context.TriggerId"
             data-state="open">
            <CascadingValue Value="Context" IsFixed="false">
                <CascadingValue Value="this" IsFixed="false">
                    @ChildContent
                </CascadingValue>
            </CascadingValue>
        </div>
    };

    private async Task SetupClickOutsideAsync()
    {
        try
        {
            _clickOutsideModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/NeoBlazorUI.Primitives/js/primitives/click-outside.js");

            _dotNetRef = DotNetObjectReference.Create(this);

            _clickOutsideCleanup = await _clickOutsideModule.InvokeAsync<IJSObjectReference>(
                "onClickOutside", _contentRef, _dotNetRef, "HandleClickOutside");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up click-outside: {ex.Message}");
        }
    }

    private async Task SetupKeyboardNavAsync()
    {
        try
        {
            _keyboardNavModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/NeoBlazorUI.Primitives/js/primitives/keyboard-nav.js");

            _dotNetRef ??= DotNetObjectReference.Create(this);

            _keyboardNavCleanup = await _keyboardNavModule.InvokeAsync<IJSObjectReference>(
                "setupKeyboardNav", _contentRef, _dotNetRef);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up keyboard navigation: {ex.Message}");
        }
    }

    private async Task SetupScrollLockAsync()
    {
        try
        {
            _scrollLockModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/NeoBlazorUI.Primitives/js/primitives/portal.js");

            _scrollLockCleanup = await _scrollLockModule.InvokeAsync<IJSObjectReference>(
                "lockBodyScroll");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up scroll lock: {ex.Message}");
        }
    }

    [JSInvokable]
    public Task HandleClickOutside()
    {
        if (!Context.IsOpen) return Task.CompletedTask;

        if (CloseOnClickOutside)
        {
            Context.Close();
        }

        return Task.CompletedTask;
    }

    private async void HandleContextStateChanged()
    {
        if (!Context.IsOpen)
        {
            await InvokeAsync(async () =>
            {
                await CleanupAsync();
                StateHasChanged();
            });
        }
        else
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Escape")
        {
            if (CloseOnEscape)
            {
                Context.Close();
            }
            return;
        }

        // Arrow navigation - use JS to navigate in DOM order
        if (_keyboardNavModule == null) return;

        try
        {
            switch (args.Key)
            {
                case "ArrowDown":
                    await _keyboardNavModule.InvokeVoidAsync("navigateNext", _contentRef, Loop);
                    break;

                case "ArrowUp":
                    await _keyboardNavModule.InvokeVoidAsync("navigatePrevious", _contentRef, Loop);
                    break;

                case "Home":
                    await _keyboardNavModule.InvokeVoidAsync("navigateFirst", _contentRef);
                    break;

                case "End":
                    await _keyboardNavModule.InvokeVoidAsync("navigateLast", _contentRef);
                    break;
            }
        }
        catch
        {
            // Ignore navigation errors
        }
    }

    private string GetOverlayStyle()
    {
        // Overlay should be below the context menu content but above regular content
        var overlayZIndex = ZIndex - 1;
        return $"position: fixed; inset: 0; z-index: {overlayZIndex};";
    }

    /// <summary>
    /// Registers a menu item for keyboard navigation.
    /// </summary>
    internal void RegisterItem(IContextMenuItem item)
    {
        if (!_menuItems.Contains(item))
        {
            _menuItems.Add(item);
        }
    }

    /// <summary>
    /// Unregisters a menu item.
    /// </summary>
    internal void UnregisterItem(IContextMenuItem item)
    {
        _menuItems.Remove(item);
    }

    /// <summary>
    /// Focuses the content container for keyboard navigation.
    /// </summary>
    internal async Task FocusContainerAsync()
    {
        if (_keyboardNavModule != null)
        {
            try
            {
                var focused = await _keyboardNavModule.InvokeAsync<bool>("focusElement", _contentRef);
                if (!focused)
                {
                    // Fallback to C# focus
                    await _contentRef.FocusAsync();
                }
                _focusedItemIndex = -1;
            }
            catch
            {
                // Fallback to C# focus
                try
                {
                    await _contentRef.FocusAsync();
                    _focusedItemIndex = -1;
                }
                catch
                {
                    // Focus failed
                }
            }
        }
        else
        {
            // JS module not loaded, use C# focus
            try
            {
                await _contentRef.FocusAsync();
                _focusedItemIndex = -1;
            }
            catch
            {
                // Focus failed
            }
        }
    }

    private async Task CleanupAsync()
    {
        _focusedItemIndex = -1;

        if (_clickOutsideCleanup != null)
        {
            try
            {
                await _clickOutsideCleanup.InvokeVoidAsync("dispose");
                await _clickOutsideCleanup.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Expected during circuit disconnection, ignore
            }
            catch (ObjectDisposedException)
            {
                // Already disposed, ignore
            }
            _clickOutsideCleanup = null;
        }

        if (_keyboardNavCleanup != null)
        {
            try
            {
                await _keyboardNavCleanup.InvokeVoidAsync("dispose");
                await _keyboardNavCleanup.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Expected during circuit disconnection, ignore
            }
            catch (ObjectDisposedException)
            {
                // Already disposed, ignore
            }
            _keyboardNavCleanup = null;
        }

        // Unlock body scroll
        if (_scrollLockCleanup != null)
        {
            try
            {
                await _scrollLockCleanup.InvokeVoidAsync("apply");
                await _scrollLockCleanup.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Expected during circuit disconnection, ignore
            }
            catch (ObjectDisposedException)
            {
                // Already disposed, ignore
            }
            _scrollLockCleanup = null;
        }

        if (_clickOutsideModule != null)
        {
            try
            {
                await _clickOutsideModule.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Expected during circuit disconnection, ignore
            }
            catch (ObjectDisposedException)
            {
                // Already disposed, ignore
            }
            _clickOutsideModule = null;
        }

        if (_keyboardNavModule != null)
        {
            try
            {
                await _keyboardNavModule.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Expected during circuit disconnection, ignore
            }
            catch (ObjectDisposedException)
            {
                // Already disposed, ignore
            }
            _keyboardNavModule = null;
        }

        if (_scrollLockModule != null)
        {
            try
            {
                await _scrollLockModule.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Expected during circuit disconnection, ignore
            }
            catch (ObjectDisposedException)
            {
                // Already disposed, ignore
            }
            _scrollLockModule = null;
        }

        // Dispose DotNetObjectReference
        _dotNetRef?.Dispose();
        _dotNetRef = null;
    }

    public async ValueTask DisposeAsync()
    {
        Context.OnStateChanged -= HandleContextStateChanged;
        await CleanupAsync();
    }
}
