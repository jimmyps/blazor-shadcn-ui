@namespace BlazorUI.Primitives.ContextMenu
@using BlazorUI.Primitives.Services
@inject IPositioningService PositioningService
@inject IPortalService PortalService
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

@* ContextMenuContent - the dropdown content for the context menu *@

@code {
    [CascadingParameter]
    private ContextMenuContext Context { get; set; } = null!;

    private ElementReference _contentRef;
    private IJSObjectReference? _clickOutsideModule;
    private IJSObjectReference? _clickOutsideCleanup;
    private IJSObjectReference? _keyboardNavModule;
    private IJSObjectReference? _keyboardNavCleanup;
    private IJSObjectReference? _scrollLockModule;
    private IJSObjectReference? _scrollLockCleanup;
    private IAsyncDisposable? _positioningCleanup;
    private DotNetObjectReference<ContextMenuContent>? _dotNetRef;
    private bool _isInitialized = false;
    private bool _isPositioned = false;
    private string _portalId = "";
    private ElementReference _portalContentRef;
    private TaskCompletionSource<bool>? _portalReadyTcs;

    // Track menu items for keyboard navigation (consistent with DropdownMenu/Menubar pattern)
    private readonly List<IContextMenuItem> _menuItems = new();
    private int _focusedItemIndex = -1;

    /// <summary>
    /// The content to render inside the menu.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Additional attributes to apply to the content container.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Whether pressing Escape should close the menu.
    /// </summary>
    [Parameter]
    public bool CloseOnEscape { get; set; } = true;

    /// <summary>
    /// Whether clicking outside should close the menu.
    /// </summary>
    [Parameter]
    public bool CloseOnClickOutside { get; set; } = true;

    /// <summary>
    /// Z-index value for the menu content.
    /// </summary>
    [Parameter]
    public int ZIndex { get; set; } = 50;

    /// <summary>
    /// Whether to enable keyboard loop navigation.
    /// Default is true.
    /// </summary>
    [Parameter]
    public bool Loop { get; set; } = true;

    /// <summary>
    /// CSS class for the overlay element.
    /// </summary>
    [Parameter]
    public string? OverlayClass { get; set; }

    /// <summary>
    /// Whether to lock body scroll when menu is open.
    /// Default is false (context menus typically don't lock scroll).
    /// </summary>
    [Parameter]
    public bool LockScroll { get; set; } = false;

    /// <summary>
    /// Padding from viewport edges when repositioning the menu.
    /// Default is 8 pixels.
    /// </summary>
    [Parameter]
    public int ViewportPadding { get; set; } = 8;

    protected override void OnInitialized()
    {
        if (Context == null)
        {
            throw new InvalidOperationException(
                "ContextMenuContent must be used within a ContextMenuRoot component.");
        }

        _portalId = $"contextmenu-portal-{Context.ContentId}";

        Context.OnStateChanged += HandleContextStateChanged;

        // Subscribe to portal ready events for synchronization
        PortalService.OnPortalRendered += HandlePortalRendered;
    }

    private void HandlePortalRendered(string portalId)
    {
        if (portalId == _portalId)
        {
            _portalReadyTcs?.TrySetResult(true);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (Context.IsOpen && !_isInitialized)
        {
            _isInitialized = true;
            _isPositioned = false;

            // Create completion source BEFORE registering portal
            _portalReadyTcs = new TaskCompletionSource<bool>();

            // Register context menu content through portal
            PortalService.RegisterPortal(_portalId, RenderContextMenuContent());

            // Wait for PortalHost to signal it's done rendering our portal
            var timeoutTask = Task.Delay(500);
            var completedTask = await Task.WhenAny(_portalReadyTcs.Task, timeoutTask);

            if (completedTask == timeoutTask)
            {
                Console.WriteLine($"Warning: Portal {_portalId} render timeout");
            }

            // Yield to ensure any pending re-renders complete and _portalContentRef is up-to-date
            await Task.Yield();

            // Check if still open (user might have closed during wait)
            if (!Context.IsOpen)
            {
                return;
            }

            // NOW _portalContentRef is guaranteed to be valid!
            await SetupAsync();
        }
        else if (!Context.IsOpen && _isInitialized)
        {
            await CleanupAsync();
        }
    }

    /// <summary>
    /// Sets up all context menu functionality after portal has rendered.
    /// </summary>
    private async Task SetupAsync()
    {
        try
        {
            // Set up positioning at mouse coordinates
            await SetupPositioningAsync();

            // Mark as positioned
            _isPositioned = true;

            if (CloseOnClickOutside)
            {
                await SetupClickOutsideAsync();
            }

            // Set up keyboard navigation
            await SetupKeyboardNavAsync();

            // Lock body scroll when menu is open (if enabled)
            if (LockScroll)
            {
                await SetupScrollLockAsync();
            }

            try
            {
                await _portalContentRef.FocusAsync();
            }
            catch
            {
                // Focus may fail in some scenarios
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Context menu setup failed: {ex.Message}");
            _isPositioned = true;
        }
    }

    private RenderFragment RenderContextMenuContent() => __builder =>
    {
        @* Transparent overlay to capture clicks outside the menu *@
        <div class="@OverlayClass"
             style="@GetOverlayStyle()"
             data-state="open">
        </div>
        
        <div @ref="_portalContentRef"
             id="@Context.ContentId"
             role="menu"
             tabindex="-1"
             @onkeydown="HandleKeyDown"
             @attributes="GetAttributesWithoutStyle()"
             aria-labelledby="@Context.TriggerId"
             data-state="open"
             style="@GetMergedStyle()">
            <CascadingValue Value="Context" IsFixed="false">
                <CascadingValue Value="this" IsFixed="false">
                    @ChildContent
                </CascadingValue>
            </CascadingValue>
        </div>
    };

    private async Task SetupPositioningAsync()
    {
        try
        {
            // For context menus, we use the mouse coordinates as a virtual reference point
            // Create a positioning strategy that uses fixed positioning at the cursor location
            var options = new PositioningOptions
            {
                Strategy = "fixed",
                Flip = true,
                Shift = true,
                Padding = ViewportPadding
            };

            // Since we don't have a trigger element, we'll position at the cursor coordinates
            // and let the shift middleware ensure it stays within the viewport
            // Apply initial position at cursor coordinates
            await JSRuntime.InvokeVoidAsync("eval", 
                $"const el = document.getElementById('{Context.ContentId}'); " +
                $"if (el) {{ " +
                $"  el.style.position = 'fixed'; " +
                $"  el.style.left = '{Context.X}px'; " +
                $"  el.style.top = '{Context.Y}px'; " +
                $"  el.style.opacity = '1'; " +
                $"  el.style.pointerEvents = 'auto'; " +
                $"  const rect = el.getBoundingClientRect(); " +
                $"  const vw = window.innerWidth; " +
                $"  const vh = window.innerHeight; " +
                $"  let newX = {Context.X}; " +
                $"  let newY = {Context.Y}; " +
                $"  if (newX + rect.width > vw - {ViewportPadding}) {{ newX = vw - rect.width - {ViewportPadding}; }} " +
                $"  if (newY + rect.height > vh - {ViewportPadding}) {{ newY = vh - rect.height - {ViewportPadding}; }} " +
                $"  if (newX < {ViewportPadding}) {{ newX = {ViewportPadding}; }} " +
                $"  if (newY < {ViewportPadding}) {{ newY = {ViewportPadding}; }} " +
                $"  el.style.left = newX + 'px'; " +
                $"  el.style.top = newY + 'px'; " +
                $"}}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up context menu positioning: {ex.Message}");
        }
    }

    private async Task SetupClickOutsideAsync()
    {
        try
        {
            _clickOutsideModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/NeoBlazorUI.Primitives/js/primitives/click-outside.js");

            _dotNetRef = DotNetObjectReference.Create(this);

            _clickOutsideCleanup = await _clickOutsideModule.InvokeAsync<IJSObjectReference>(
                "onClickOutside", _portalContentRef, _dotNetRef, "HandleClickOutside");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up click-outside: {ex.Message}");
        }
    }

    private async Task SetupKeyboardNavAsync()
    {
        try
        {
            _keyboardNavModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/NeoBlazorUI.Primitives/js/primitives/keyboard-nav.js");

            _dotNetRef ??= DotNetObjectReference.Create(this);

            _keyboardNavCleanup = await _keyboardNavModule.InvokeAsync<IJSObjectReference>(
                "setupKeyboardNav", _portalContentRef, _dotNetRef);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up keyboard navigation: {ex.Message}");
        }
    }

    private async Task SetupScrollLockAsync()
    {
        try
        {
            _scrollLockModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/NeoBlazorUI.Primitives/js/primitives/portal.js");

            _scrollLockCleanup = await _scrollLockModule.InvokeAsync<IJSObjectReference>(
                "lockBodyScroll");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up scroll lock: {ex.Message}");
        }
    }

    [JSInvokable]
    public Task HandleClickOutside()
    {
        if (!Context.IsOpen) return Task.CompletedTask;

        if (CloseOnClickOutside)
        {
            Context.Close();
        }

        return Task.CompletedTask;
    }

    private async void HandleContextStateChanged()
    {
        if (!Context.IsOpen && _isInitialized)
        {
            await InvokeAsync(async () =>
            {
                await CleanupAsync();
                StateHasChanged();
            });
        }
        else
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Escape")
        {
            if (CloseOnEscape)
            {
                Context.Close();
            }
            return;
        }

        // Arrow navigation - filter enabled items first (following DropdownMenu pattern)
        var enabledItems = _menuItems.Where(item => !item.Disabled).ToList();
        if (enabledItems.Count == 0) return;

        switch (args.Key)
        {
            case "ArrowDown":
                await NavigateNext(enabledItems);
                break;

            case "ArrowUp":
                await NavigatePrevious(enabledItems);
                break;

            case "Home":
                await FocusItem(enabledItems, 0);
                break;

            case "End":
                await FocusItem(enabledItems, enabledItems.Count - 1);
                break;
        }
    }

    private async Task NavigateNext(List<IContextMenuItem> enabledItems)
    {
        int nextIndex;

        if (_focusedItemIndex == -1)
        {
            // No item focused, focus first
            nextIndex = 0;
        }
        else
        {
            // Find current item in enabled list
            var currentEnabledIndex = GetEnabledItemIndex(enabledItems, _focusedItemIndex);

            if (currentEnabledIndex == -1)
            {
                // Current item not in enabled list, focus first
                nextIndex = 0;
            }
            else if (currentEnabledIndex == enabledItems.Count - 1)
            {
                // At last item
                if (Loop)
                {
                    nextIndex = 0; // Wrap to first
                }
                else
                {
                    return; // Don't move
                }
            }
            else
            {
                nextIndex = currentEnabledIndex + 1;
            }
        }

        await FocusItem(enabledItems, nextIndex);
    }

    private async Task NavigatePrevious(List<IContextMenuItem> enabledItems)
    {
        int prevIndex;

        if (_focusedItemIndex == -1)
        {
            // No item focused, focus last
            prevIndex = enabledItems.Count - 1;
        }
        else
        {
            // Find current item in enabled list
            var currentEnabledIndex = GetEnabledItemIndex(enabledItems, _focusedItemIndex);

            if (currentEnabledIndex == -1)
            {
                // Current item not in enabled list, focus last
                prevIndex = enabledItems.Count - 1;
            }
            else if (currentEnabledIndex == 0)
            {
                // At first item
                if (Loop)
                {
                    prevIndex = enabledItems.Count - 1; // Wrap to last
                }
                else
                {
                    return; // Don't move
                }
            }
            else
            {
                prevIndex = currentEnabledIndex - 1;
            }
        }

        await FocusItem(enabledItems, prevIndex);
    }

    private int GetEnabledItemIndex(List<IContextMenuItem> enabledItems, int absoluteIndex)
    {
        if (absoluteIndex < 0 || absoluteIndex >= _menuItems.Count) return -1;

        var currentItem = _menuItems[absoluteIndex];
        return enabledItems.IndexOf(currentItem);
    }

    private async Task FocusItem(List<IContextMenuItem> enabledItems, int enabledIndex)
    {
        if (enabledIndex < 0 || enabledIndex >= enabledItems.Count) return;

        var item = enabledItems[enabledIndex];
        var absoluteIndex = _menuItems.IndexOf(item);

        _focusedItemIndex = absoluteIndex;
        await item.FocusAsync();
    }

    private string GetOverlayStyle()
    {
        var overlayZIndex = Math.Max(0, ZIndex - 1);
        return $"position: fixed; inset: 0; z-index: {overlayZIndex};";
    }

    private string GetInitialStyle()
    {
        var baseStyle = $"z-index: {ZIndex};";

        if (!_isPositioned)
        {
            // Position off-screen initially to prevent focus-induced scroll
            baseStyle += " position: fixed; top: -9999px; left: -9999px; pointer-events: none;";
        }
        else
        {
            // Initial position at mouse coordinates - JS will adjust if needed for viewport bounds
            baseStyle += $" position: fixed; left: {Context.X}px; top: {Context.Y}px;";
        }

        return baseStyle;
    }

    private string GetMergedStyle()
    {
        var baseStyle = GetInitialStyle();

        if (AdditionalAttributes != null && AdditionalAttributes.TryGetValue("style", out var userStyle))
        {
            return $"{userStyle}; {baseStyle}";
        }

        return baseStyle;
    }

    private Dictionary<string, object>? GetAttributesWithoutStyle()
    {
        if (AdditionalAttributes == null) return null;

        var attributes = new Dictionary<string, object>(AdditionalAttributes);
        attributes.Remove("style");

        return attributes.Count > 0 ? attributes : null;
    }

    /// <summary>
    /// Registers a menu item for keyboard navigation.
    /// </summary>
    internal void RegisterItem(IContextMenuItem item)
    {
        if (!_menuItems.Contains(item))
        {
            _menuItems.Add(item);
        }
    }

    /// <summary>
    /// Unregisters a menu item.
    /// </summary>
    internal void UnregisterItem(IContextMenuItem item)
    {
        _menuItems.Remove(item);
    }

    /// <summary>
    /// Focuses the content container for keyboard navigation.
    /// </summary>
    internal async Task FocusContainerAsync()
    {
        try
        {
            await _portalContentRef.FocusAsync();
            _focusedItemIndex = -1;
        }
        catch
        {
            // Focus may fail
        }
    }

    private async Task CleanupAsync()
    {
        _isInitialized = false;
        _focusedItemIndex = -1;

        if (_positioningCleanup != null)
        {
            await _positioningCleanup.DisposeAsync();
            _positioningCleanup = null;
        }

        if (_clickOutsideCleanup != null)
        {
            try
            {
                await _clickOutsideCleanup.InvokeVoidAsync("dispose");
                await _clickOutsideCleanup.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Expected during circuit disconnection, ignore
            }
            catch (ObjectDisposedException)
            {
                // Already disposed, ignore
            }
            _clickOutsideCleanup = null;
        }

        if (_keyboardNavCleanup != null)
        {
            try
            {
                await _keyboardNavCleanup.InvokeVoidAsync("dispose");
                await _keyboardNavCleanup.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Expected during circuit disconnection, ignore
            }
            catch (ObjectDisposedException)
            {
                // Already disposed, ignore
            }
            _keyboardNavCleanup = null;
        }

        // Unlock body scroll
        if (_scrollLockCleanup != null)
        {
            try
            {
                await _scrollLockCleanup.InvokeVoidAsync("apply");
                await _scrollLockCleanup.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Expected during circuit disconnection, ignore
            }
            catch (ObjectDisposedException)
            {
                // Already disposed, ignore
            }
            _scrollLockCleanup = null;
        }

        if (_clickOutsideModule != null)
        {
            try
            {
                await _clickOutsideModule.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Expected during circuit disconnection, ignore
            }
            catch (ObjectDisposedException)
            {
                // Already disposed, ignore
            }
            _clickOutsideModule = null;
        }

        if (_keyboardNavModule != null)
        {
            try
            {
                await _keyboardNavModule.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Expected during circuit disconnection, ignore
            }
            catch (ObjectDisposedException)
            {
                // Already disposed, ignore
            }
            _keyboardNavModule = null;
        }

        if (_scrollLockModule != null)
        {
            try
            {
                await _scrollLockModule.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Expected during circuit disconnection, ignore
            }
            catch (ObjectDisposedException)
            {
                // Already disposed, ignore
            }
            _scrollLockModule = null;
        }

        // Dispose DotNetObjectReference
        _dotNetRef?.Dispose();
        _dotNetRef = null;

        // Unregister portal when context menu closes
        if (!string.IsNullOrEmpty(_portalId))
        {
            PortalService.UnregisterPortal(_portalId);
        }

        _isPositioned = false;
    }

    public async ValueTask DisposeAsync()
    {
        // Unsubscribe from portal ready events
        PortalService.OnPortalRendered -= HandlePortalRendered;

        Context.OnStateChanged -= HandleContextStateChanged;
        await CleanupAsync();
    }
}
