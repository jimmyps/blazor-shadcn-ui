@namespace BlazorUI.Primitives.Popover
@using BlazorUI.Primitives.Services
@inject IPositioningService PositioningService
@inject IPortalService PortalService
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

@*
    PopoverContent is the main content container for the popover.
    Handles positioning, click-outside, escape key, and ARIA attributes.
    Renders through a portal to avoid z-index stacking issues.
*@

@code {
    [CascadingParameter]
    private PopoverContext Context { get; set; } = null!;

    /// <summary>
    /// The content to render inside the popover.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Additional attributes to apply to the content container.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Whether pressing Escape should close the popover.
    /// Default is true.
    /// </summary>
    [Parameter]
    public bool CloseOnEscape { get; set; } = true;

    /// <summary>
    /// Whether clicking outside should close the popover.
    /// Default is true.
    /// </summary>
    [Parameter]
    public bool CloseOnClickOutside { get; set; } = true;

    /// <summary>
    /// Preferred side for positioning.
    /// Default is Bottom.
    /// </summary>
    [Parameter]
    public PopoverSide Side { get; set; } = PopoverSide.Bottom;

    /// <summary>
    /// Alignment relative to trigger.
    /// Default is Center.
    /// </summary>
    [Parameter]
    public PopoverAlign Align { get; set; } = PopoverAlign.Center;

    /// <summary>
    /// Offset distance from the trigger element in pixels.
    /// Default is 4.
    /// </summary>
    [Parameter]
    public int Offset { get; set; } = 4;

    /// <summary>
    /// Event callback invoked when Escape key is pressed.
    /// </summary>
    [Parameter]
    public EventCallback<KeyboardEventArgs> OnEscapeKeyDown { get; set; }

    /// <summary>
    /// Event callback invoked when clicking outside the popover.
    /// </summary>
    [Parameter]
    public EventCallback OnClickOutside { get; set; }

    private IJSObjectReference? _clickOutsideModule;
    private IJSObjectReference? _clickOutsideCleanup;
    private DotNetObjectReference<PopoverContent>? _dotNetRef;
    private IAsyncDisposable? _positioningCleanup;
    private bool _isInitialized = false;
    private bool _isPositioned = false;
    private string _portalId = "";
    private ElementReference _portalContentRef;
    private TaskCompletionSource<bool>? _portalReadyTcs;

    // Store computed position so it survives Blazor re-renders
    private double _positionLeft = 0;
    private double _positionTop = 0;

    protected override void OnInitialized()
    {
        if (Context == null)
        {
            throw new InvalidOperationException(
                "PopoverContent must be used within a Popover component. " +
                "Ensure PopoverContent is a child of a Popover component.");
        }

        _portalId = $"popover-portal-{Context.ContentId}";

        // Subscribe to context changes
        Context.OnStateChanged += HandleContextStateChanged;

        // Subscribe to portal ready events for synchronization
        PortalService.OnPortalRendered += HandlePortalRendered;
    }

    private void HandlePortalRendered(string portalId)
    {
        if (portalId == _portalId)
        {
            _portalReadyTcs?.TrySetResult(true);
        }
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        // Refresh portal to re-render with updated ChildContent
        // Now safe because GetInitialStyle() includes the stored position,
        // so re-renders won't lose the position styling
        if (_isInitialized && Context.IsOpen && !string.IsNullOrEmpty(_portalId))
        {
            PortalService.RefreshPortal(_portalId);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (Context.IsOpen && !_isInitialized)
        {
            _isInitialized = true;
            _isPositioned = false;

            // Create completion source BEFORE registering portal
            _portalReadyTcs = new TaskCompletionSource<bool>();

            // Register popover content through portal - this triggers PortalHost to re-render
            PortalService.RegisterPortal(_portalId, RenderPopoverContent());

            // Wait for PortalHost to signal it's done rendering our portal
            // Use timeout to prevent hanging if something goes wrong
            var timeoutTask = Task.Delay(500);
            var completedTask = await Task.WhenAny(_portalReadyTcs.Task, timeoutTask);

            if (completedTask == timeoutTask)
            {
                Console.WriteLine($"Warning: Portal {_portalId} render timeout");
            }

            // Yield to ensure any pending re-renders complete and _portalContentRef is up-to-date
            // This is critical when multiple portals are opening/closing simultaneously
            await Task.Yield();

            // Check if still open (user might have closed during wait)
            if (!Context.IsOpen)
            {
                return;
            }

            // NOW _portalContentRef is guaranteed to be valid!
            await SetupAsync();
        }
        else if (!Context.IsOpen && _isInitialized)
        {
            await CleanupAsync();
        }
    }

    /// <summary>
    /// Sets up all popover functionality after portal has rendered.
    /// </summary>
    private async Task SetupAsync()
    {
        try
        {
            // Set up positioning and make visible via JS
            await SetupPositioningAsync();

            // Mark as positioned for any future Blazor re-renders
            _isPositioned = true;

            // Set up click-outside detection
            if (CloseOnClickOutside)
            {
                await SetupClickOutsideAsync();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Popover setup failed: {ex.Message}");
            // Mark as positioned and show via JS even if setup fails
            _isPositioned = true;
            try
            {
                await JSRuntime.InvokeVoidAsync("eval", $"document.getElementById('{Context.ContentId}').style.opacity = '1'; document.getElementById('{Context.ContentId}').style.pointerEvents = 'auto';");
            }
            catch { /* ignore */ }
        }
    }

    private RenderFragment RenderPopoverContent() => __builder =>
    {
        <div @ref="_portalContentRef"
             id="@Context.ContentId"
             role="group"
             tabindex="-1"
             @onkeydown="HandleKeyDown"
             @attributes="GetAttributesWithoutStyle()"
             data-state="open"
             data-portal-content="true"
             style="@GetMergedStyle()">
            @ChildContent
        </div>
    };

    private async Task SetupPositioningAsync()
    {
        if (Context.State.TriggerElement == null)
        {
            Console.WriteLine("Warning: PopoverContent - TriggerElement is null, positioning may not work correctly");
            return;
        }

        try
        {
            // Construct placement string from Side and Align
            var placement = Align == PopoverAlign.Center ? Side.ToValue() : $"{Side.ToValue()}-{Align.ToValue()}";

            var options = new PositioningOptions
            {
                Placement = placement,
                Offset = Offset
            };

            // Compute position using the portal content ref
            var position = await PositioningService.ComputePositionAsync(
                Context.State.TriggerElement.Value,
                _portalContentRef,
                options);

            // Store position in Blazor state so it survives re-renders
            _positionLeft = position.X;
            _positionTop = position.Y;

            // Apply position via JS for initial display
            await PositioningService.ApplyPositionAsync(_portalContentRef, position, makeVisible: true);

            // Set up auto-update for dynamic positioning (scroll, resize)
            _positioningCleanup = await PositioningService.AutoUpdateAsync(
                Context.State.TriggerElement.Value,
                _portalContentRef,
                options);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up positioning: {ex.Message}");
        }
    }

    private async Task SetupClickOutsideAsync()
    {
        try
        {
            _clickOutsideModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/BlazorUI.Primitives/js/primitives/click-outside.js");

            _dotNetRef = DotNetObjectReference.Create(this);

            // Use ID-based lookup instead of ElementReference
            // This ensures we always reference the current DOM element, not a stale one
            // that may have been replaced during Blazor re-renders
            _clickOutsideCleanup = await _clickOutsideModule.InvokeAsync<IJSObjectReference>(
                "onClickOutsideByIds",
                Context.ContentId,      // Element ID (not ElementReference)
                _dotNetRef,
                "HandleClickOutside",
                Context.TriggerId);     // Trigger ID (not ElementReference)
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up click-outside: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task HandleClickOutside()
    {
        if (!Context.IsOpen) return;

        // Invoke custom handler if provided
        if (OnClickOutside.HasDelegate)
        {
            await OnClickOutside.InvokeAsync();
        }

        // Close popover if configured
        if (CloseOnClickOutside)
        {
            Context.Close();
        }
    }

    /// <summary>
    /// Gets the initial inline style for the portal content.
    /// </summary>
    private string GetInitialStyle()
    {
        if (!_isPositioned)
        {
            // Use position: fixed with off-screen coordinates to prevent:
            // 1. Flash at wrong position (fixed doesn't depend on parent context)
            // 2. Scroll jump (visibility: hidden prevents browser from scrolling to element)
            // 3. Layout interference (pointer-events: none prevents interaction)
            return "position: fixed; z-index: 50; top: -9999px; left: -9999px; visibility: hidden; opacity: 0; pointer-events: none;";
        }

        // After positioning, include stored position so it survives Blazor re-renders
        // This prevents the popover from "closing" when parent components re-render
        return $"position: absolute; z-index: 50; left: {_positionLeft}px; top: {_positionTop}px; opacity: 1; visibility: visible;";
    }

    private string GetMergedStyle()
    {
        var baseStyle = GetInitialStyle();

        if (AdditionalAttributes != null && AdditionalAttributes.TryGetValue("style", out var userStyle))
        {
            return $"{userStyle}; {baseStyle}";
        }

        return baseStyle;
    }

    private Dictionary<string, object>? GetAttributesWithoutStyle()
    {
        if (AdditionalAttributes == null) return null;

        var attributes = new Dictionary<string, object>(AdditionalAttributes);
        attributes.Remove("style");

        return attributes.Count > 0 ? attributes : null;
    }

    private async void HandleContextStateChanged()
    {
        if (!Context.IsOpen && _isInitialized)
        {
            // Popover closed, clean up
            await InvokeAsync(async () =>
            {
                await CleanupAsync();
                StateHasChanged();
            });
        }
        else
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Escape")
        {
            // Invoke custom handler if provided
            if (OnEscapeKeyDown.HasDelegate)
            {
                await OnEscapeKeyDown.InvokeAsync(args);
            }

            // Close popover if configured
            if (CloseOnEscape)
            {
                Context.Close();
            }
        }
    }

    private async Task CleanupAsync()
    {
        // Dispose positioning auto-update
        if (_positioningCleanup != null)
        {
            await _positioningCleanup.DisposeAsync();
            _positioningCleanup = null;
        }

        // Remove click-outside listener by invoking dispose method
        if (_clickOutsideCleanup != null)
        {
            try
            {
                await _clickOutsideCleanup.InvokeVoidAsync("dispose");
                await _clickOutsideCleanup.DisposeAsync();
            }
            catch
            {
                // Cleanup may already be disposed
            }
            _clickOutsideCleanup = null;
        }

        // Dispose DotNetObjectReference to prevent stale callbacks
        if (_dotNetRef != null)
        {
            _dotNetRef.Dispose();
            _dotNetRef = null;
        }

        // Unregister portal when popover closes
        if (!string.IsNullOrEmpty(_portalId))
        {
            PortalService.UnregisterPortal(_portalId);
        }

        _isInitialized = false;
        _isPositioned = false;
    }

    public async ValueTask DisposeAsync()
    {
        // Unsubscribe from portal ready events
        PortalService.OnPortalRendered -= HandlePortalRendered;

        await CleanupAsync();

        if (_clickOutsideModule != null)
        {
            await _clickOutsideModule.DisposeAsync();
        }

        _dotNetRef?.Dispose();

        if (Context != null)
        {
            Context.OnStateChanged -= HandleContextStateChanged;
        }
    }
}
