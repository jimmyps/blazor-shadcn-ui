@namespace BlazorUI.Components.Chart
@typeparam TData
@inherits LineChartBase<TData>
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<CascadingValue Value="(IChartStyleContainer)this" IsFixed="true">
    <div class="@ContainerClass" style="position: relative; height: @(Height)px; width: 100%;">
        <div @ref="_chartContainer" style="width: 100%; height: 100%;"></div>
        
        @if (_initializationError != null)
        {
            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-center; background: hsl(var(--muted)); border-radius: var(--radius); padding: 2rem;">
                <div style="text-align: center; max-width: 400px;">
                    <div style="color: hsl(var(--destructive)); margin-bottom: 0.5rem; font-weight: 600;">
                        Failed to initialize chart
                    </div>
                    <div style="color: hsl(var(--muted-foreground)); font-size: 0.875rem;">
                        @_initializationError
                    </div>
                </div>
            </div>
        }
        
        @if (ShowExportButton && _isInitialized)
        {
            <div style="position: absolute; top: 8px; right: 8px; z-index: 10;">
                <button @onclick="ExportAsPng" 
                        class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-9 w-9"
                        title="Export chart">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/>
                        <line x1="12" x2="12" y1="15" y2="3"/>
                    </svg>
                </button>
            </div>
        }
        
        @* Render ChartStyle child content (hidden, just for data collection) *@
        @if (ChildContent != null)
        {
            <div style="display: none;">
                @ChildContent
            </div>
        }
    </div>
</CascadingValue>

@code {
    private ElementReference _chartContainer;
    private IChartRenderer? _renderer;
    private string? _chartId;
    private bool _isInitialized;
    private bool _shouldRender = false;
    private string? _initializationError;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Trigger a second render to allow ChartStyle children to initialize
            _shouldRender = true;
            StateHasChanged();
        }
        else if (_shouldRender && Data != null && Data.Any())
        {
            _shouldRender = false;
            await InitializeChartAsync();
        }
    }
    
    protected override async Task OnParametersSetAsync()
    {
        if (_isInitialized && Data != null && Data.Any())
        {
            await UpdateChartDataAsync();
        }
    }
    
    private async Task InitializeChartAsync()
    {
        try
        {
            _renderer = ChartRendererFactory.CreateRenderer(Engine, JSRuntime);
            
            // Generate ECharts v6 config directly (not Chart.js format)
            var echartsConfig = BuildEChartsConfig();
            
            _chartId = await _renderer.InitializeAsync(_chartContainer, echartsConfig);
            _isInitialized = true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"LineChart: Failed to initialize chart: {ex.Message}");
            _initializationError = ex.Message;
        }
    }
    
    private async Task ExportAsPng()
    {
        if (_renderer == null || string.IsNullOrEmpty(_chartId))
        {
            Console.WriteLine("LineChart: Cannot export - chart not initialized");
            return;
        }
        
        try
        {
            var format = Engine == ChartEngine.ECharts ? ImageFormat.Svg : ImageFormat.Png;
            var dataUrl = await _renderer.ExportAsImageAsync(_chartId, format);
            
            if (string.IsNullOrEmpty(dataUrl))
            {
                Console.WriteLine("LineChart: Export returned empty data URL");
                return;
            }
            
            // Trigger download via JS helper
            var extension = format == ImageFormat.Svg ? "svg" : "png";
            var filename = $"{ExportFileName}.{extension}";
            await DownloadFile(dataUrl, filename);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"LineChart: Export failed - {ex.Message}");
        }
    }
    
    private async Task DownloadFile(string dataUrl, string filename)
    {
        var script = @"
            (function(url, name) {
                const link = document.createElement('a');
                link.href = url;
                link.download = name;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            })(arguments[0], arguments[1]);
        ";
        await JSRuntime.InvokeVoidAsync("eval", script, dataUrl, filename);
    }
    
    private async Task UpdateChartDataAsync()
    {
        if (_renderer != null && !string.IsNullOrEmpty(_chartId))
        {
            try
            {
                var echartsConfig = BuildEChartsConfig();
                await _renderer.UpdateDataAsync(_chartId, echartsConfig);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to update chart data: {ex.Message}");
            }
        }
    }
    
    /// <summary>
    /// Builds ECharts v6 configuration object directly (not Chart.js format).
    /// </summary>
    private object BuildEChartsConfig()
    {
        if (Data == null || !Data.Any())
        {
            return new
            {
                xAxis = new { type = "category", data = Array.Empty<string>() },
                yAxis = new { type = "value" },
                series = Array.Empty<object>()
            };
        }
        
        var labels = ExtractLabels();
        var values = ExtractValues();
        
        return new
        {
            animationDuration = DisableAnimations ? 0 : (Animation?.Duration ?? 750),
            animationEasing = MapEasingToECharts(Animation?.Easing ?? AnimationEasing.EaseInOutQuart),
            tooltip = new
            {
                show = ShowTooltip,
                trigger = "axis"
            },
            legend = new
            {
                show = ShowLegend,
                top = "top",
                left = "center"
            },
            xAxis = new
            {
                type = "category",
                data = labels,
                show = ShowXAxis,
                boundaryGap = false,
                axisLine = new { show = ShowXAxis },
                splitLine = new { show = ShowGrid }
            },
            yAxis = new
            {
                type = "value",
                show = ShowYAxis,
                axisLine = new { show = ShowYAxis },
                splitLine = new { show = ShowGrid }
            },
            series = new[]
            {
                BuildEChartsSeries(values)
            }
        };
    }
    
    /// <summary>
    /// Builds a single ECharts series object.
    /// </summary>
    private object BuildEChartsSeries(double[] values)
    {
        // Determine configuration source: ChartStyle or direct parameters
        var lineStyle = _chartStyle?.LineStyle;
        var areaStyle = _chartStyle?.AreaStyle;
        var pointStyle = _chartStyle?.PointStyle;
        
        // Line color from ChartStyle or parameter
        var color = lineStyle?.Color ?? LineColor ?? "hsl(var(--chart-1))";
        
        // Line width from ChartStyle or parameter
        var lineWidth = lineStyle?.Width ?? LineWidth;
        
        // Smooth/curved from ChartStyle or parameter
        var smooth = lineStyle?.Smooth ?? Curved;
        
        // Fill area determination
        var fillArea = areaStyle?.Show ?? FillArea;
        
        // Point configuration
        var showDots = pointStyle?.Show ?? ShowDots;
        var pointSize = pointStyle?.Size ?? 4;
        
        var series = new Dictionary<string, object>
        {
            ["name"] = Label ?? YAxisDataKey,
            ["type"] = "line",
            ["data"] = values,
            ["smooth"] = smooth ? 0.4 : 0,
            ["showSymbol"] = showDots,
            ["symbolSize"] = showDots ? pointSize : 0
        };
        
        // Line style
        var lineTypeValue = lineStyle?.Type == LineType.Dashed ? "dashed" : 
                           lineStyle?.Type == LineType.Dotted ? "dotted" : "solid";
        series["lineStyle"] = new
        {
            color = color,
            width = lineWidth,
            type = lineTypeValue
        };
        
        // Item style (for point markers)
        series["itemStyle"] = new { color = color };
        
        // Area style with gradient support
        if (fillArea)
        {
            if (areaStyle?.Gradient != null)
            {
                // Use ChartStyle gradient
                var gradient = areaStyle.Gradient;
                var (x, y, x2, y2) = GetGradientCoordinates(gradient.Direction);
                
                series["areaStyle"] = new
                {
                    color = new
                    {
                        type = "linear",
                        x, y, x2, y2,
                        colorStops = gradient.ColorStops.Select(stop => new
                        {
                            offset = stop.Offset,
                            color = stop.Color
                        }).ToArray(),
                        @global = false
                    }
                };
            }
            else if (GradientFill)
            {
                // Fallback to parameter-based gradient
                series["areaStyle"] = new
                {
                    color = new
                    {
                        type = "linear",
                        x = 0,
                        y = 0,
                        x2 = 0,
                        y2 = 1,
                        colorStops = new[]
                        {
                            new { offset = 0.0, color = $"hsla(var(--chart-1), {GradientStartOpacity})" },
                            new { offset = 1.0, color = $"hsla(var(--chart-1), {GradientEndOpacity})" }
                        },
                        @global = false
                    }
                };
            }
            else
            {
                // Simple solid fill
                series["areaStyle"] = new { opacity = 0.3 };
            }
        }
        
        return series;
    }
    
    private string[] ExtractLabels()
    {
        if (Data == null || !Data.Any()) return Array.Empty<string>();
        
        // If DataKey is specified for X axis, use that property
        if (!string.IsNullOrEmpty(XAxisDataKey))
        {
            return Data.Select(item =>
            {
                var prop = item?.GetType().GetProperty(XAxisDataKey);
                return prop?.GetValue(item)?.ToString() ?? "";
            }).ToArray();
        }
        
        // Otherwise use indices
        return Data.Select((_, i) => i.ToString()).ToArray();
    }
    
    private double[] ExtractValues()
    {
        if (string.IsNullOrEmpty(YAxisDataKey))
        {
            return Array.Empty<double>();
        }
        
        return Data.Select(item =>
        {
            var prop = item?.GetType().GetProperty(YAxisDataKey);
            var value = prop?.GetValue(item);
            
            if (value == null) return 0.0;
            
            return Convert.ToDouble(value);
        }).ToArray();
    }
    
    private string MapEasingToECharts(AnimationEasing easing)
    {
        return easing switch
        {
            AnimationEasing.Linear => "linear",
            AnimationEasing.EaseInQuad => "quadraticIn",
            AnimationEasing.EaseOutQuad => "quadraticOut",
            AnimationEasing.EaseInOutQuad => "quadraticInOut",
            AnimationEasing.EaseInCubic => "cubicIn",
            AnimationEasing.EaseOutCubic => "cubicOut",
            AnimationEasing.EaseInOutCubic => "cubicInOut",
            AnimationEasing.EaseInQuart => "quarticIn",
            AnimationEasing.EaseOutQuart => "quarticOut",
            AnimationEasing.EaseInOutQuart => "quarticInOut",
            _ => "quarticInOut"
        };
    }
    
    /// <summary>
    /// Gets gradient coordinates based on direction.
    /// </summary>
    private (double x, double y, double x2, double y2) GetGradientCoordinates(GradientDirection direction)
    {
        return direction switch
        {
            GradientDirection.Vertical => (0, 0, 0, 1),
            GradientDirection.Horizontal => (0, 0, 1, 0),
            GradientDirection.TopLeftToBottomRight => (0, 0, 1, 1),
            GradientDirection.TopRightToBottomLeft => (1, 0, 0, 1),
            GradientDirection.BottomLeftToTopRight => (0, 1, 1, 0),
            GradientDirection.BottomRightToTopLeft => (1, 1, 0, 0),
            _ => (0, 0, 0, 1) // Default to vertical
        };
    }
    
    public async ValueTask DisposeAsync()
    {
        if (_renderer != null && !string.IsNullOrEmpty(_chartId))
        {
            try
            {
                await _renderer.DestroyAsync(_chartId);
            }
            catch
            {
                // Ignore disposal errors
            }
        }
        
        if (_renderer != null)
        {
            try
            {
                await _renderer.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
    }
}
