@namespace BlazorUI.Components.Command
@using BlazorUI.Components.Input
@using BlazorUI.Components.Common
@using Microsoft.JSInterop
@implements IAsyncDisposable

<div class="@CssClass" data-command-input-wrapper>
    <svg xmlns="http://www.w3.org/2000/svg"
         width="24"
         height="24"
         viewBox="0 0 24 24"
         fill="none"
         stroke="currentColor"
         stroke-width="2"
         stroke-linecap="round"
         stroke-linejoin="round"
         class="mr-2 h-4 w-4 shrink-0 opacity-50">
        <circle cx="11" cy="11" r="8"></circle>
        <path d="m21 21-4.35-4.35"></path>
    </svg>
    <Input @ref="@_inputRef"
           Id="@InputId"
           Type="InputType.Text"
           Value="@Context?.SearchQuery"
           ValueChanged="HandleValueChanged"
           UpdateOn="InputUpdateMode.Input"
           DebounceDelay="SearchInterval"
           Placeholder="@Placeholder"
           Disabled="@Disabled"
           Class="flex h-11 w-full rounded-none !border-0 bg-transparent px-0 py-3 !shadow-none text-sm outline-none placeholder:text-muted-foreground focus-visible:!border-0 focus-visible:!ring-0 disabled:cursor-not-allowed disabled:opacity-50"
           AdditionalAttributes="@InputAttributes" />

</div>

@code {
    [Inject]
    private IJSRuntime JSRuntime { get; set; } = default!;

    [CascadingParameter]
    public CommandContext? Context { get; set; }

    private BlazorUI.Components.Input.Input? _inputRef;
    private IJSObjectReference? _inputModule;
    private DotNetObjectReference<CommandInput>? _dotNetRef;
    private bool _jsInitialized = false;
    private bool _previousAutoFocus;
    private bool _shouldFocus;
    private string? _generatedInputId;

    /// <summary>
    /// Gets or sets additional CSS classes to apply to the input container.
    /// </summary>
    [Parameter]
    public string? Class { get; set; }

    /// <summary>
    /// Gets or sets the placeholder text for the input.
    /// </summary>
    [Parameter]
    public string Placeholder { get; set; } = "Type a command or search...";

    /// <summary>
    /// Gets or sets whether the input is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Gets or sets whether the input should auto-focus when rendered.
    /// </summary>
    [Parameter]
    public bool AutoFocus { get; set; }

    /// <summary>
    /// Gets or sets the debounce interval in milliseconds before triggering search.
    /// Default is 0 (no debouncing). Set to 150-300ms for better performance with large datasets.
    /// </summary>
    [Parameter]
    public int SearchInterval { get; set; } = 0;

    /// <summary>
    /// Gets the ID to use for the input element.
    /// Generates a unique ID if not explicitly set.
    /// </summary>
    private string InputId => _generatedInputId ??= "command-input-" + Guid.NewGuid().ToString("N")[..6];

    /// <summary>
    /// Additional attributes for ARIA and role.
    /// Cached to prevent unnecessary re-renders of Input component.
    /// </summary>
    private Dictionary<string, object> InputAttributes => new()
    {
        { "role", "combobox" },
        { "aria-autocomplete", "list" },
        { "aria-expanded", "true" },
        { "aria-controls", Context?.ListId ?? "" }
        // âœ… No more onkeydown - handled in JavaScript!
    };

    /// <summary>
    /// Focuses the input element.
    /// </summary>
    public async Task FocusAsync()
    {
        if (_inputRef != null)
        {
            try
            {
                // Input component doesn't expose FocusAsync yet, so we'll need to add it
                // For now, this will be a no-op until Input component is enhanced
                await Task.CompletedTask;
            }
            catch
            {
                // Ignore focus errors
            }
        }
    }

    /// <summary>
    /// Gets the computed CSS classes for the input container.
    /// </summary>
    private string CssClass
    {
        get
        {
            var baseClasses = "flex items-center border-b border-border px-3";
            return string.IsNullOrWhiteSpace(Class) ? baseClasses : $"{baseClasses} {Class}";
        }
    }

    protected override void OnParametersSet()
    {
        // Check if AutoFocus changed from false to true
        if (AutoFocus && !_previousAutoFocus)
        {
            _shouldFocus = true;
        }
        _previousAutoFocus = AutoFocus;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // Import the input module
                _inputModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "import", "./_content/NeoBlazorUI.Components/js/input.js");

                // Create DotNetObjectReference for callbacks
                _dotNetRef = DotNetObjectReference.Create(this);

                // Initialize command input keyboard navigation
                // JavaScript will intercept arrow keys and call HandleNavigationKey
                await _inputModule.InvokeVoidAsync(
                    "initializeCommandInput",
                    InputId,
                    _dotNetRef
                );

                _jsInitialized = true;
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Error initializing command input JS: {ex.Message}");
            }
        }

        // Focus when AutoFocus becomes true (either on first render or when popover opens)
        if (_shouldFocus)
        {
            _shouldFocus = false;
            await FocusAsync();
        }
    }

    private void HandleValueChanged(string? value)
    {
        // Update CommandContext with new search query
        Context?.SetSearchQuery(value ?? string.Empty);
    }

    /// <summary>
    /// Called from JavaScript when navigation keys are pressed.
    /// This is invoked ONLY for ArrowDown, ArrowUp, Home, End, Enter.
    /// Regular typing keys never trigger C# calls.
    /// </summary>
    [JSInvokable]
    public async Task HandleNavigationKey(string key)
    {
        if (Context == null) return;

        switch (key)
        {
            case "ArrowDown":
                await Context.MoveFocusAsync(1);
                break;
            case "ArrowUp":
                await Context.MoveFocusAsync(-1);
                break;
            case "Home":
                await Context.FocusFirstAsync();
                break;
            case "End":
                await Context.FocusLastAsync();
                break;
            case "Enter":
                await Context.SelectFocusedItemAsync();
                break;
        }
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (_jsInitialized && _inputModule != null)
            {
                // Dispose command input keyboard handling
                await _inputModule.InvokeVoidAsync("disposeCommandInput", InputId);
                await _inputModule.DisposeAsync();
            }

            _dotNetRef?.Dispose();
        }
        catch (JSDisconnectedException)
        {
            // The JS runtime is already disposed
        }
        catch
        {
            // Ignore disposal errors
        }
    }
}


