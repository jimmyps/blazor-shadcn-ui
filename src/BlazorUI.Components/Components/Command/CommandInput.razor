@namespace BlazorUI.Components.Command

<div class="@CssClass">
    <svg xmlns="http://www.w3.org/2000/svg"
         width="24"
         height="24"
         viewBox="0 0 24 24"
         fill="none"
         stroke="currentColor"
         stroke-width="2"
         stroke-linecap="round"
         stroke-linejoin="round"
         class="mr-2 h-4 w-4 shrink-0 opacity-50">
        <circle cx="11" cy="11" r="8"></circle>
        <path d="m21 21-4.35-4.35"></path>
    </svg>
    <input @ref="_inputRef"
           type="text"
           placeholder="@Placeholder"
           disabled="@Disabled"
           value="@Context?.SearchQuery"
           @oninput="HandleInput"
           @onkeydown="HandleKeyDown"
           class="flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50 ml-2"
           role="combobox"
           aria-autocomplete="list"
           aria-expanded="true"
           aria-controls="@Context?.ListId" />
</div>

@code {
    [CascadingParameter]
    public CommandContext? Context { get; set; }

    /// <summary>
    /// Gets or sets additional CSS classes to apply to the input container.
    /// </summary>
    [Parameter]
    public string? Class { get; set; }

    /// <summary>
    /// Gets or sets the placeholder text for the input.
    /// </summary>
    [Parameter]
    public string Placeholder { get; set; } = "Type a command or search...";

    /// <summary>
    /// Gets or sets whether the input is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Gets or sets whether the input should auto-focus when rendered.
    /// </summary>
    [Parameter]
    public bool AutoFocus { get; set; }

    private ElementReference _inputRef;
    private bool _previousAutoFocus;
    private bool _shouldFocus;

    /// <summary>
    /// Gets the computed CSS classes for the input container.
    /// </summary>
    private string CssClass
    {
        get
        {
            var baseClasses = "flex items-center border-b border-border px-3";
            return string.IsNullOrWhiteSpace(Class) ? baseClasses : $"{baseClasses} {Class}";
        }
    }

    protected override void OnParametersSet()
    {
        // Check if AutoFocus changed from false to true
        if (AutoFocus && !_previousAutoFocus)
        {
            _shouldFocus = true;
        }
        _previousAutoFocus = AutoFocus;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Focus when AutoFocus becomes true (either on first render or when popover opens)
        if (_shouldFocus)
        {
            _shouldFocus = false;
            try
            {
                // Small delay to ensure the element is ready in the DOM (especially after portal rendering)
                await Task.Delay(50);
                await _inputRef.FocusAsync();
            }
            catch
            {
                // Ignore focus errors
            }
        }
    }

    private void HandleInput(ChangeEventArgs args)
    {
        var value = args.Value?.ToString() ?? string.Empty;
        Context?.SetSearchQuery(value);
    }

    private async Task HandleKeyDown(KeyboardEventArgs args)
    {
        if (Context == null) return;

        switch (args.Key)
        {
            case "ArrowDown":
                Context.MoveFocus(1);
                break;
            case "ArrowUp":
                Context.MoveFocus(-1);
                break;
            case "Home":
                Context.FocusFirst();
                break;
            case "End":
                Context.FocusLast();
                break;
            case "Enter":
                await Context.SelectFocusedItemAsync();
                break;
        }
    }
}
