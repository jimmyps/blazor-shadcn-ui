@namespace BlazorUI.Components.Command
@implements IDisposable

<div class="@CssClass" data-command-input-wrapper>
    <svg xmlns="http://www.w3.org/2000/svg"
         width="24"
         height="24"
         viewBox="0 0 24 24"
         fill="none"
         stroke="currentColor"
         stroke-width="2"
         stroke-linecap="round"
         stroke-linejoin="round"
         class="mr-2 h-4 w-4 shrink-0 opacity-50">
        <circle cx="11" cy="11" r="8"></circle>
        <path d="m21 21-4.35-4.35"></path>
    </svg>
    <input @ref="_inputRef"
           type="text"
           placeholder="@Placeholder"
           disabled="@Disabled"
           value="@Context?.SearchQuery"
           @oninput="HandleInput"
           @onkeydown="HandleKeyDown"
           class="flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50 ml-2"
           role="combobox"
           aria-autocomplete="list"
           aria-expanded="true"
           aria-controls="@Context?.ListId" />
</div>

@code {
    [CascadingParameter]
    public CommandContext? Context { get; set; }

    private ElementReference _inputRef;
    private bool _previousAutoFocus;
    private bool _shouldFocus;
    private System.Threading.Timer? _debounceTimer;
    private string _pendingSearchQuery = string.Empty;

    /// <summary>
    /// Gets or sets additional CSS classes to apply to the input container.
    /// </summary>
    [Parameter]
    public string? Class { get; set; }

    /// <summary>
    /// Gets or sets the placeholder text for the input.
    /// </summary>
    [Parameter]
    public string Placeholder { get; set; } = "Type a command or search...";

    /// <summary>
    /// Gets or sets whether the input is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Gets or sets whether the input should auto-focus when rendered.
    /// </summary>
    [Parameter]
    public bool AutoFocus { get; set; }

    /// <summary>
    /// Gets or sets the debounce interval in milliseconds before triggering search.
    /// Default is 0 (no debouncing). Set to 150-300ms for better performance with large datasets.
    /// </summary>
    [Parameter]
    public int SearchInterval { get; set; } = 0;

    /// <summary>
    /// Focuses the input element.
    /// </summary>
    public async Task FocusAsync()
    {
        try
        {
            await _inputRef.FocusAsync();
        }
        catch
        {
            // Ignore focus errors (element may not be ready)
        }
    }

    /// <summary>
    /// Gets the computed CSS classes for the input container.
    /// </summary>
    private string CssClass
    {
        get
        {
            var baseClasses = "flex items-center border-b border-border px-3";
            return string.IsNullOrWhiteSpace(Class) ? baseClasses : $"{baseClasses} {Class}";
        }
    }

    protected override void OnParametersSet()
    {
        // Check if AutoFocus changed from false to true
        if (AutoFocus && !_previousAutoFocus)
        {
            _shouldFocus = true;
        }
        _previousAutoFocus = AutoFocus;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Focus when AutoFocus becomes true (either on first render or when popover opens)
        if (_shouldFocus)
        {
            _shouldFocus = false;
            try
            {
                // Small delay to ensure the element is ready in the DOM (especially after portal rendering)
                await Task.Delay(50);
                await _inputRef.FocusAsync();
            }
            catch
            {
                // Ignore focus errors
            }
        }
    }

    private void HandleInput(ChangeEventArgs args)
    {
        var value = args.Value?.ToString() ?? string.Empty;

        if (SearchInterval > 0)
        {
            // Debounce the search
            _pendingSearchQuery = value;
            _debounceTimer?.Dispose();
            _debounceTimer = new System.Threading.Timer(_ =>
            {
                InvokeAsync(() => Context?.SetSearchQuery(_pendingSearchQuery));
            }, null, SearchInterval, System.Threading.Timeout.Infinite);
        }
        else
        {
            // Immediate update
            Context?.SetSearchQuery(value);
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs args)
    {
        if (Context == null) return;

        switch (args.Key)
        {
            case "ArrowDown":
                await Context.MoveFocusAsync(1);
                break;
            case "ArrowUp":
                await Context.MoveFocusAsync(-1);
                break;
            case "Home":
                await Context.FocusFirstAsync();
                break;
            case "End":
                await Context.FocusLastAsync();
                break;
            case "Enter":
                await Context.SelectFocusedItemAsync();
                break;
        }
    }

    public void Dispose()
    {
        _debounceTimer?.Dispose();
    }
}
