@namespace BlazorUI.Components.Calendar
<<<<<<< HEAD
@using System.Globalization

@* Calendar - accessible month/day grid for date selection *@
<div @ref="_calendarRef" @attributes="GetAttributes()" role="application" aria-label="Calendar" tabindex="0" 
     @onkeydown="HandleKeyDown" @onkeydown:preventDefault="@_shouldPreventDefault"
     @onfocus="OnFocus" @onblur="OnBlur" @onfocusin="OnFocusIn">
    @* Header with navigation *@
    <div class="flex flex-col space-y-4 sm:flex-row sm:space-x-4 sm:space-y-0">
        <div class="space-y-4">
            @* Month navigation *@
            <div class="relative flex w-full items-center justify-center pt-1">
                <button type="button"
                        @onclick="PreviousMonth"
                        disabled="@(!CanNavigatePrevious)"
                        class="@GetPrevNavButtonClass()"
                        aria-label="Go to previous month">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="m15 18-6-6 6-6"/>
                    </svg>
                </button>
                @if (CaptionLayout == CalendarCaptionLayout.Dropdown)
                {
                    <div class="flex items-center gap-1">
                        <select @bind="SelectedMonth" class="@GetDropdownClass()" aria-label="Select month"
                                @onfocus="() => _isDropdownFocused = true" @onblur="() => _isDropdownFocused = false">
                            @foreach (var month in GetMonths())
                            {
                                <option value="@month.Value">@month.Name</option>
                            }
                        </select>
                        <select @bind="SelectedYear" class="@GetDropdownClass()" aria-label="Select year"
                                @onfocus="() => _isDropdownFocused = true" @onblur="() => _isDropdownFocused = false">
                            @foreach (var year in GetYears())
                            {
                                <option value="@year">@year</option>
                            }
                        </select>
                    </div>
                }
                else
                {
                    <div class="text-sm font-medium" aria-live="polite">
                        @DisplayedMonth.ToString("MMMM yyyy", Culture)
                    </div>
                }
                <button type="button"
                        @onclick="NextMonth"
                        disabled="@(!CanNavigateNext)"
                        class="@GetNextNavButtonClass()"
                        aria-label="Go to next month">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="m9 18 6-6-6-6"/>
                    </svg>
                </button>
            </div>

            @* Day grid *@
            <table class="w-full border-collapse space-y-1" role="grid" aria-label="@DisplayedMonth.ToString("MMMM yyyy", Culture)">
                <thead>
                    <tr class="flex">
                        @foreach (var dayName in GetDayNames())
=======
@using BlazorUI.Components.Utilities
@using BlazorUI.Components.Button
@using BlazorUI.Components.Select
@using BlazorUI.Icons.Lucide.Components
@implements IAsyncDisposable
@inject IJSRuntime JS

@*
    Calendar component - displays a month view with selectable dates.
*@

<div class="@CssClass" @attributes="AdditionalAttributes">
    @* Calendar Header with Navigation *@
    <div class="flex flex-col space-y-4 sm:flex-row sm:space-x-4 sm:space-y-0">
        <div class="space-y-4">
            @* Month/Year Navigation *@
            <div class="flex items-center justify-between pt-1">
                <Button Variant="ButtonVariant.Outline"
                        Size="ButtonSize.Icon"
                        Class="h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
                        OnClick="@PreviousMonth"
                        AriaLabel="Go to previous month">
                    <LucideIcon Name="chevron-left" Class="h-4 w-4" />
                </Button>
                <div class="flex items-center gap-1">
                    @if (ShowMonthYearDropdowns)
                    {
                        @* Month Select *@
                        <Select TValue="int" Value="@DisplayDate.Month" ValueChanged="@OnMonthChanged" Class="w-[120px]">
                            <SelectTrigger Class="h-8 border-0 bg-transparent px-2 text-sm font-medium hover:bg-accent focus:ring-0 focus:ring-offset-0">
                                <span>@GetMonthName(DisplayDate.Month)</span>
                            </SelectTrigger>
                            <SelectContent>
                                @foreach (var month in GetMonths())
                                {
                                    <SelectItem TValue="int" Value="@month.Number" Text="@month.Name">@month.Name</SelectItem>
                                }
                            </SelectContent>
                        </Select>
                        @* Year Select *@
                        <Select TValue="int" Value="@DisplayDate.Year" ValueChanged="@OnYearChanged" Class="w-[80px]">
                            <SelectTrigger Class="h-8 border-0 bg-transparent px-2 text-sm font-medium hover:bg-accent focus:ring-0 focus:ring-offset-0">
                                <span>@DisplayDate.Year</span>
                            </SelectTrigger>
                            <SelectContent>
                                @foreach (var year in GetYears())
                                {
                                    <SelectItem TValue="int" Value="@year" Text="@year.ToString()">@year</SelectItem>
                                }
                            </SelectContent>
                        </Select>
                    }
                    else
                    {
                        @* Simple month/year text header *@
                        <span class="text-sm font-medium">@GetMonthName(DisplayDate.Month) @DisplayDate.Year</span>
                    }
                </div>
                <Button Variant="ButtonVariant.Outline"
                        Size="ButtonSize.Icon"
                        Class="h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
                        OnClick="@NextMonth"
                        AriaLabel="Go to next month">
                    <LucideIcon Name="chevron-right" Class="h-4 w-4" />
                </Button>
            </div>

            @* Calendar Grid *@
            <table class="w-full border-collapse space-y-1" role="grid"
                   @onkeydown="HandleKeyDown"
                   @onkeydown:preventDefault="@ShouldPreventKeyDefault">
                <thead>
                    <tr class="flex">
                        @foreach (var dayName in DayNames)
>>>>>>> 8835bfed9859e4bf8349954ac05f732fe9ffddcf
                        {
                            <th scope="col" class="text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]">
                                @dayName
                            </th>
                        }
                    </tr>
                </thead>
<<<<<<< HEAD
                <tbody @key="_displayedMonth">
                    @foreach (var week in GetWeeks())
                    {
                        <tr class="@ClassNames.cn("flex w-full mt-2", RowClass)">
                            @foreach (var day in week)
                            {
                                <td class="relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md">
                                    @if (day.HasValue)
                                    {
                                        <button type="button"
                                                tabindex="-1"
                                                @onclick="@(() => { SelectDate(day.Value); _calendarRef.FocusAsync(); })"
                                                disabled="@(!IsDateEnabled(day.Value))"
                                                class="@GetDayClass(day.Value)"
                                                data-focused="@IsFocused(day.Value)"
                                                aria-label="@day.Value.ToString("D", Culture)"
                                                aria-selected="@IsSelected(day.Value)">
                                            @day.Value.Day
                                        </button>
                                    }
                                    else
                                    {
                                        <span class="inline-flex h-9 w-9"></span>
                                    }
=======
                <tbody>
                    @foreach (var week in GetWeeksInMonth())
                    {
                        <tr class="flex w-full mt-2">
                            @foreach (var day in week)
                            {
                                var isSelected = day.HasValue && Selected.HasValue && day.Value.Date == Selected.Value.Date;
                                var isDisabled = day.HasValue && (IsDisabled(day.Value) || day.Value.Month != DisplayDate.Month);
                                var isFocused = day.HasValue && _focusedDate.HasValue && day.Value.Date == _focusedDate.Value.Date;
                                <td class="@GetCellClasses(day, isSelected)"
                                    role="gridcell"
                                    aria-selected="@isSelected">
                                    @if (day.HasValue)
                                    {
                                        <button type="button"
                                                id="@GetDayId(day.Value)"
                                                class="@GetDayClasses(day.Value, isSelected, isDisabled, isFocused)"
                                                disabled="@isDisabled"
                                                tabindex="@(isFocused ? 0 : -1)"
                                                @onclick="@(() => SelectDate(day.Value))"
                                                @onclick:stopPropagation="true"
                                                @onfocus="@(() => HandleDayFocus(day.Value))">
                                            @day.Value.Day
                                        </button>
                                    }
>>>>>>> 8835bfed9859e4bf8349954ac05f732fe9ffddcf
                                </td>
                            }
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    </div>
</div>

@code {
<<<<<<< HEAD
    private DateOnly _displayedMonth;
    private DateOnly _focusedDate;
    private DateOnly? _previousSelectedDate;
    private ElementReference _calendarRef;
    private bool _shouldPreventDefault;
    private bool _isDropdownFocused;
    private bool _hasFocus;
    private bool _needsRefocus;
    
    /// <summary>
    /// Programmatically focuses the calendar container.
    /// </summary>
    public async Task FocusAsync()
    {
        await _calendarRef.FocusAsync();
    }
    
    /// <summary>
    /// The currently selected date.
    /// </summary>
    [Parameter]
    public DateOnly? SelectedDate { get; set; }

    /// <summary>
    /// Event callback invoked when the selected date changes.
    /// </summary>
    [Parameter]
    public EventCallback<DateOnly?> SelectedDateChanged { get; set; }
=======
    private DateTime _displayDate;
    private DateTime? _previousSelected;
    private IJSObjectReference? _elementUtilsModule;

    // Keyboard navigation fields
    private DateTime? _focusedDate;
    private bool _isKeyboardNavigating;
    private readonly string _calendarId = $"calendar-{Guid.NewGuid():N}";

    // Caching fields
    private DayOfWeek _cachedFirstDayOfWeek;
    private bool _cachedShowOutsideDays;
    private string[]? _cachedDayNames;
    private List<List<DateTime?>>? _cachedWeeks;

    // ShouldRender tracking fields
    private DateTime? _lastSelected;
    private DateTime _lastDisplayDate;
    private DateTime? _lastMinDate;
    private DateTime? _lastMaxDate;
    private bool _lastShowMonthYearDropdowns;
    private DateTime? _lastFocusedDate;
    private bool _lastIsKeyboardNavigating;

    /// <summary>
    /// The currently displayed month.
    /// </summary>
    private DateTime DisplayDate
    {
        get => _displayDate;
        set
        {
            if (_displayDate.Year != value.Year || _displayDate.Month != value.Month)
                _cachedWeeks = null;
            _displayDate = value;
        }
    }

    /// <summary>
    /// The selected date (for single mode).
    /// </summary>
    [Parameter]
    public DateTime? Selected { get; set; }

    /// <summary>
    /// Callback when the selected date changes.
    /// </summary>
    [Parameter]
    public EventCallback<DateTime?> SelectedChanged { get; set; }

    /// <summary>
    /// The selection mode of the calendar.
    /// </summary>
    [Parameter]
    public CalendarMode Mode { get; set; } = CalendarMode.Single;
>>>>>>> 8835bfed9859e4bf8349954ac05f732fe9ffddcf

    /// <summary>
    /// The minimum selectable date.
    /// </summary>
    [Parameter]
<<<<<<< HEAD
    public DateOnly? MinDate { get; set; }
=======
    public DateTime? MinDate { get; set; }
>>>>>>> 8835bfed9859e4bf8349954ac05f732fe9ffddcf

    /// <summary>
    /// The maximum selectable date.
    /// </summary>
    [Parameter]
<<<<<<< HEAD
    public DateOnly? MaxDate { get; set; }

    /// <summary>
    /// The culture to use for formatting.
    /// Default is the current culture.
    /// </summary>
    [Parameter]
    public CultureInfo Culture { get; set; } = CultureInfo.CurrentCulture;

    /// <summary>
    /// The initial month to display.
    /// Defaults to the selected date's month or current month.
    /// </summary>
    [Parameter]
    public DateOnly? InitialMonth { get; set; }

    /// <summary>
    /// Function to determine if a specific date is disabled.
    /// </summary>
    [Parameter]
    public Func<DateOnly, bool>? IsDateDisabled { get; set; }
=======
    public DateTime? MaxDate { get; set; }

    /// <summary>
    /// Function to determine if a date is disabled.
    /// </summary>
    [Parameter]
    public Func<DateTime, bool>? DisabledDates { get; set; }

    /// <summary>
    /// The first day of the week.
    /// </summary>
    [Parameter]
    public DayOfWeek FirstDayOfWeek { get; set; } = DayOfWeek.Sunday;

    /// <summary>
    /// Whether to show days from previous and next months.
    /// </summary>
    [Parameter]
    public bool ShowOutsideDays { get; set; } = true;

    /// <summary>
    /// Whether to show month and year dropdown selectors.
    /// When false, displays a simple text header instead.
    /// </summary>
    [Parameter]
    public bool ShowMonthYearDropdowns { get; set; } = true;
>>>>>>> 8835bfed9859e4bf8349954ac05f732fe9ffddcf

    /// <summary>
    /// Additional CSS classes to apply to the calendar.
    /// </summary>
    [Parameter]
    public string? Class { get; set; }

    /// <summary>
<<<<<<< HEAD
    /// Additional CSS classes to apply to each week row in the day grid.
    /// </summary>
    [Parameter]
    public string? RowClass { get; set; }

    /// <summary>
    /// Additional attributes to apply to the calendar element.
=======
    /// Additional CSS classes to apply to day buttons.
    /// </summary>
    [Parameter]
    public string? DayClass { get; set; }

    /// <summary>
    /// Additional CSS classes to apply to day cells (td elements).
    /// </summary>
    [Parameter]
    public string? CellClass { get; set; }

    /// <summary>
    /// Additional attributes to apply to the calendar.
>>>>>>> 8835bfed9859e4bf8349954ac05f732fe9ffddcf
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
<<<<<<< HEAD
    /// The caption layout mode for month/year display.
    /// Default is Label (static text). Dropdown allows quick month/year selection.
    /// </summary>
    [Parameter]
    public CalendarCaptionLayout CaptionLayout { get; set; } = CalendarCaptionLayout.Label;

    /// <summary>
    /// The number of years to show before and after the current year in dropdown mode.
    /// Default is 20 years in each direction.
    /// </summary>
    [Parameter]
    public int YearRange { get; set; } = 20;

    /// <summary>
    /// The start date of a range selection (for visual styling).
    /// </summary>
    [Parameter]
    public DateOnly? RangeStart { get; set; }

    /// <summary>
    /// The end date of a range selection (for visual styling).
    /// </summary>
    [Parameter]
    public DateOnly? RangeEnd { get; set; }

    /// <summary>
    /// Event callback invoked when the displayed month changes.
    /// This fires whenever the user navigates to a different month via buttons, keyboard, or dropdown.
    /// </summary>
    [Parameter]
    public EventCallback<DateOnly> DisplayedMonthChanged { get; set; }

    public void NavigateMonth(DateOnly month, bool notifyMonthChanged = false)
    {
        if (month != _displayedMonth)
        {
            _displayedMonth = month;

            if (notifyMonthChanged)
                _ = NotifyMonthChanged();
        }
    }

    private DateOnly DisplayedMonth => _displayedMonth;

    /// <summary>
    /// Property for binding the selected month in dropdown mode.
    /// </summary>
    private int SelectedMonth
    {
        get => _displayedMonth.Month;
        set
        {
            if (value != _displayedMonth.Month)
            {
                var daysInNewMonth = DateTime.DaysInMonth(_displayedMonth.Year, value);
                var preservedDay = Math.Min(_focusedDate.Day, daysInNewMonth);
                _displayedMonth = new DateOnly(_displayedMonth.Year, value, 1);
                _focusedDate = new DateOnly(_displayedMonth.Year, value, preservedDay);
                _ = NotifyMonthChanged();
            }
        }
    }

    /// <summary>
    /// Property for binding the selected year in dropdown mode.
    /// </summary>
    private int SelectedYear
    {
        get => _displayedMonth.Year;
        set
        {
            if (value != _displayedMonth.Year)
            {
                var daysInNewMonth = DateTime.DaysInMonth(value, _displayedMonth.Month);
                var preservedDay = Math.Min(_focusedDate.Day, daysInNewMonth);
                _displayedMonth = new DateOnly(value, _displayedMonth.Month, 1);
                _focusedDate = new DateOnly(value, _displayedMonth.Month, preservedDay);
                _ = NotifyMonthChanged();
            }
        }
    }

    protected override void OnInitialized()
    {
        _displayedMonth = InitialMonth ?? SelectedDate ?? DateOnly.FromDateTime(DateTime.Today);
        _displayedMonth = new DateOnly(_displayedMonth.Year, _displayedMonth.Month, 1);
        _focusedDate = SelectedDate ?? DateOnly.FromDateTime(DateTime.Today);
=======
    /// Callback when a date is selected.
    /// </summary>
    [Parameter]
    public EventCallback<DateTime> OnSelect { get; set; }

    protected override void OnInitialized()
    {
        _displayDate = Selected ?? DateTime.Today;
        _previousSelected = Selected;
        InitializeFocusedDate();
>>>>>>> 8835bfed9859e4bf8349954ac05f732fe9ffddcf
    }

    protected override void OnParametersSet()
    {
<<<<<<< HEAD
        // Only update focused date if selected date actually changed
        if (SelectedDate.HasValue && SelectedDate != _previousSelectedDate)
        {
            var selectedMonth = new DateOnly(SelectedDate.Value.Year, SelectedDate.Value.Month, 1);
            if (selectedMonth != _displayedMonth)
            {
                _displayedMonth = selectedMonth;
            }
            _focusedDate = SelectedDate.Value;
        }
        _previousSelectedDate = SelectedDate;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Refocus the calendar container after month changes due to keyboard navigation
        // This is needed because @key="_displayedMonth" on tbody recreates the DOM,
        // which causes the browser to lose focus on the calendar container
        if (_needsRefocus)
        {
            _needsRefocus = false;
            await _calendarRef.FocusAsync();
            // Trigger re-render to update focus ring visibility after focus is restored
            // The FocusAsync() call triggers OnFocus which sets _hasFocus = true,
            // but we need StateHasChanged to re-render and show the focus ring
            StateHasChanged();
        }
    }

    /// <summary>
    /// Gets the list of months for dropdown selection.
    /// </summary>
    private IEnumerable<(int Value, string Name)> GetMonths()
    {
        for (int i = 1; i <= 12; i++)
        {
            var date = new DateOnly(2000, i, 1);
            yield return (i, date.ToString("MMMM", Culture));
        }
    }

    /// <summary>
    /// Gets the list of years for dropdown selection.
    /// </summary>
    private IEnumerable<int> GetYears()
    {
        var startYear = MinDate?.Year ?? DateTime.Today.Year - YearRange;
        var endYear = MaxDate?.Year ?? DateTime.Today.Year + YearRange;
        
        // Ensure valid range
        if (startYear > endYear)
        {
            (startYear, endYear) = (endYear, startYear);
        }
        
        for (int year = startYear; year <= endYear; year++)
=======
        // Only sync display date when Selected actually changes from external source
        // This prevents overwriting user's month/year navigation
        if (Selected != _previousSelected)
        {
            _previousSelected = Selected;
            if (Selected.HasValue)
            {
                _displayDate = Selected.Value;
                _focusedDate = Selected.Value;
            }
        }

        // Invalidate caches when relevant parameters change
        if (_cachedFirstDayOfWeek != FirstDayOfWeek)
        {
            _cachedFirstDayOfWeek = FirstDayOfWeek;
            _cachedDayNames = null;
            _cachedWeeks = null;
        }

        if (_cachedShowOutsideDays != ShowOutsideDays)
        {
            _cachedShowOutsideDays = ShowOutsideDays;
            _cachedWeeks = null;
        }
    }

    private void InitializeFocusedDate()
    {
        // Priority: Selected date > Today (if in current month) > First day of month
        if (Selected.HasValue && Selected.Value.Month == DisplayDate.Month &&
            Selected.Value.Year == DisplayDate.Year)
        {
            _focusedDate = Selected.Value.Date;
        }
        else if (DateTime.Today.Month == DisplayDate.Month &&
                 DateTime.Today.Year == DisplayDate.Year)
        {
            _focusedDate = DateTime.Today;
        }
        else
        {
            _focusedDate = GetFirstEnabledDayOfMonth();
        }
    }

    private DateTime GetFirstEnabledDayOfMonth()
    {
        var date = new DateTime(DisplayDate.Year, DisplayDate.Month, 1);
        var lastDay = date.AddMonths(1).AddDays(-1);
        while (date <= lastDay && IsDisabled(date))
        {
            date = date.AddDays(1);
        }
        return date <= lastDay ? date : new DateTime(DisplayDate.Year, DisplayDate.Month, 1);
    }

    private DateTime GetLastEnabledDayOfMonth()
    {
        var date = new DateTime(DisplayDate.Year, DisplayDate.Month, 1).AddMonths(1).AddDays(-1);
        var firstDay = new DateTime(DisplayDate.Year, DisplayDate.Month, 1);
        while (date >= firstDay && IsDisabled(date))
        {
            date = date.AddDays(-1);
        }
        return date >= firstDay ? date : new DateTime(DisplayDate.Year, DisplayDate.Month, 1).AddMonths(1).AddDays(-1);
    }

    private static readonly string[] BaseDayNames = { "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" };

    private string[] DayNames => _cachedDayNames ??= BuildDayNames();

    private string[] BuildDayNames()
    {
        var start = (int)FirstDayOfWeek;
        var result = new string[7];
        for (int i = 0; i < 7; i++)
        {
            result[i] = BaseDayNames[(start + i) % 7];
        }
        return result;
    }

    #region Navigation

    private void PreviousMonth()
    {
        DisplayDate = DisplayDate.AddMonths(-1);
        InitializeFocusedDate();
    }

    private void NextMonth()
    {
        DisplayDate = DisplayDate.AddMonths(1);
        InitializeFocusedDate();
    }

    private void OnMonthChanged(int month)
    {
        DisplayDate = new DateTime(DisplayDate.Year, month, 1);
        InitializeFocusedDate();
    }

    private void OnYearChanged(int year)
    {
        DisplayDate = new DateTime(year, DisplayDate.Month, 1);
        InitializeFocusedDate();
    }

    #endregion

    #region Keyboard Navigation

    // Always prevent default for navigation keys to stop page scrolling
    private bool ShouldPreventKeyDefault => true;

    private string GetDayId(DateTime date) => $"{_calendarId}-day-{date:yyyyMMdd}";

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        // Determine if we should handle this key
        var shouldHandle = e.Key is "ArrowLeft" or "ArrowRight" or "ArrowUp" or "ArrowDown"
            or "Home" or "End" or "PageUp" or "PageDown" or "Enter" or " ";

        if (!shouldHandle) return;

        _isKeyboardNavigating = true;

        switch (e.Key)
        {
            case "ArrowLeft":
                await NavigateDay(-1);
                break;
            case "ArrowRight":
                await NavigateDay(1);
                break;
            case "ArrowUp":
                await NavigateDay(-7);
                break;
            case "ArrowDown":
                await NavigateDay(7);
                break;
            case "Home":
                await NavigateToFirstOfMonth();
                break;
            case "End":
                await NavigateToLastOfMonth();
                break;
            case "PageUp":
                await NavigateMonth(e.ShiftKey ? -12 : -1);
                break;
            case "PageDown":
                await NavigateMonth(e.ShiftKey ? 12 : 1);
                break;
            case "Enter":
            case " ":
                await SelectFocusedDate();
                break;
        }
    }

    private async Task NavigateDay(int days)
    {
        var currentFocus = _focusedDate ?? Selected ?? DateTime.Today;
        var newDate = currentFocus.AddDays(days);

        // Skip disabled dates in the navigation direction
        var direction = days > 0 ? 1 : -1;
        var maxIterations = 365; // Prevent infinite loops
        var iterations = 0;
        while (IsDisabled(newDate) && iterations < maxIterations)
        {
            newDate = newDate.AddDays(direction);
            iterations++;
        }

        // Check if we're still within valid bounds
        if (MinDate.HasValue && newDate < MinDate.Value.Date) return;
        if (MaxDate.HasValue && newDate > MaxDate.Value.Date) return;
        if (IsDisabled(newDate)) return;

        // Handle month boundary - auto-navigate
        if (newDate.Month != DisplayDate.Month || newDate.Year != DisplayDate.Year)
        {
            DisplayDate = new DateTime(newDate.Year, newDate.Month, 1);
        }

        _focusedDate = newDate;
        await FocusCurrentButton();
    }

    private async Task NavigateToFirstOfMonth()
    {
        _focusedDate = GetFirstEnabledDayOfMonth();
        await FocusCurrentButton();
    }

    private async Task NavigateToLastOfMonth()
    {
        _focusedDate = GetLastEnabledDayOfMonth();
        await FocusCurrentButton();
    }

    private async Task NavigateMonth(int months)
    {
        var currentFocus = _focusedDate ?? Selected ?? DateTime.Today;
        var targetMonth = DisplayDate.AddMonths(months);
        DisplayDate = new DateTime(targetMonth.Year, targetMonth.Month, 1);

        // Try to maintain the same day number if possible
        var targetDay = Math.Min(currentFocus.Day, DateTime.DaysInMonth(targetMonth.Year, targetMonth.Month));
        var newDate = new DateTime(targetMonth.Year, targetMonth.Month, targetDay);

        // Find nearest enabled date if the target is disabled
        if (IsDisabled(newDate))
        {
            _focusedDate = GetFirstEnabledDayOfMonth();
        }
        else
        {
            _focusedDate = newDate;
        }

        await FocusCurrentButton();
    }

    private async Task SelectFocusedDate()
    {
        if (_focusedDate.HasValue && !IsDisabled(_focusedDate.Value))
        {
            await SelectDate(_focusedDate.Value);
        }
    }

    private async Task FocusCurrentButton()
    {
        if (!_focusedDate.HasValue) return;

        StateHasChanged();
        await Task.Yield(); // Allow render to complete

        try
        {
            var elementId = GetDayId(_focusedDate.Value);
            _elementUtilsModule ??= await JS.InvokeAsync<IJSObjectReference>(
                "import", "./_content/BlazorUI.Primitives/js/primitives/element-utils.js");
            await _elementUtilsModule.InvokeVoidAsync("focusElement", elementId);
        }
        catch
        {
            // Ignore focus errors (element may not exist yet)
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_elementUtilsModule != null)
        {
            try
            {
                await _elementUtilsModule.DisposeAsync();
            }
            catch
            {
                // Module may already be disposed
            }
        }
    }

    private void HandleDayFocus(DateTime date)
    {
        // Sync focused date when user clicks/tabs to a day
        _focusedDate = date;
        // Don't reset _isKeyboardNavigating here - let it persist until mouse click
    }

    #endregion

    #region Month/Year Data

    private static readonly string[] MonthNames = { "January", "February", "March", "April", "May", "June",
                                                     "July", "August", "September", "October", "November", "December" };

    // Cached CSS class constants for performance
    private const string CellBaseClasses = "h-9 w-9 text-center text-sm p-0 relative";
    private const string CellSelectedClasses = "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md";
    private const string CellEmptyClasses = "h-9 w-9 text-center text-sm p-0 relative text-muted-foreground opacity-50";

    private const string DayBaseClasses = "inline-flex h-9 w-9 items-center justify-center rounded-md text-sm font-normal ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 hover:bg-accent hover:text-accent-foreground";
    private const string DaySelectedClasses = "inline-flex h-9 w-9 items-center justify-center rounded-md text-sm font-normal ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground";
    private const string DayTodayClasses = "inline-flex h-9 w-9 items-center justify-center rounded-md text-sm font-normal ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 hover:bg-accent hover:text-accent-foreground bg-accent text-accent-foreground";
    private const string DayDisabledClasses = "inline-flex h-9 w-9 items-center justify-center rounded-md text-sm font-normal ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 hover:bg-accent hover:text-accent-foreground text-muted-foreground opacity-50";

    private string GetMonthName(int month) => MonthNames[month - 1];

    private IEnumerable<(int Number, string Name)> GetMonths()
    {
        for (int i = 1; i <= 12; i++)
        {
            yield return (i, MonthNames[i - 1]);
        }
    }

    private IEnumerable<int> GetYears()
    {
        var currentYear = DateTime.Today.Year;
        // Show 100 years range: 50 years back and 50 years forward
        for (int year = currentYear - 50; year <= currentYear + 50; year++)
>>>>>>> 8835bfed9859e4bf8349954ac05f732fe9ffddcf
        {
            yield return year;
        }
    }

<<<<<<< HEAD
    /// <summary>
    /// Handles keyboard navigation within the calendar.
    /// </summary>
    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        // Don't handle keyboard events when dropdown selects have focus
        if (_isDropdownFocused) return;
        
        _shouldPreventDefault = false;
        
        switch (e.Key)
        {
            case "ArrowLeft":
                _shouldPreventDefault = true;
                MoveFocus(-1);
                break;
            case "ArrowRight":
                _shouldPreventDefault = true;
                MoveFocus(1);
                break;
            case "ArrowUp":
                _shouldPreventDefault = true;
                MoveFocus(-7);
                break;
            case "ArrowDown":
                _shouldPreventDefault = true;
                MoveFocus(7);
                break;
            case "Enter":
            case " ":
                _shouldPreventDefault = true;
                if (IsDateEnabled(_focusedDate))
                {
                    await SelectDate(_focusedDate);
                }
                break;
            case "Home":
                _shouldPreventDefault = true;
                _focusedDate = new DateOnly(_focusedDate.Year, _focusedDate.Month, 1);
                ClampFocusedDateToRange();
                EnsureVisibleMonth();
                break;
            case "End":
                _shouldPreventDefault = true;
                _focusedDate = new DateOnly(_focusedDate.Year, _focusedDate.Month, DateTime.DaysInMonth(_focusedDate.Year, _focusedDate.Month));
                ClampFocusedDateToRange();
                EnsureVisibleMonth();
                break;
            case "PageUp":
                _shouldPreventDefault = true;
                _focusedDate = e.ShiftKey
                    ? _focusedDate.AddYears(-1)
                    : _focusedDate.AddMonths(-1);
                ClampFocusedDateToRange();
                EnsureVisibleMonth();
                break;
            case "PageDown":
                _shouldPreventDefault = true;
                _focusedDate = e.ShiftKey
                    ? _focusedDate.AddYears(1)
                    : _focusedDate.AddMonths(1);
                ClampFocusedDateToRange();
                EnsureVisibleMonth();
                break;
        }
        StateHasChanged();
    }

    /// <summary>
    /// Moves focus by the specified number of days, respecting date constraints.
    /// </summary>
    private void MoveFocus(int days)
    {
        _focusedDate = _focusedDate.AddDays(days);
        ClampFocusedDateToRange();
        EnsureVisibleMonth();
    }

    /// <summary>
    /// Clamps the focused date to be within MinDate and MaxDate constraints.
    /// </summary>
    private void ClampFocusedDateToRange()
    {
        if (MinDate.HasValue && _focusedDate < MinDate.Value)
        {
            _focusedDate = MinDate.Value;
        }
        if (MaxDate.HasValue && _focusedDate > MaxDate.Value)
        {
            _focusedDate = MaxDate.Value;
        }
    }

    /// <summary>
    /// Ensures the focused date's month is visible.
    /// Sets _needsRefocus flag when month changes to restore focus after DOM recreation.
    /// </summary>
    private void EnsureVisibleMonth()
    {
        var focusedMonth = new DateOnly(_focusedDate.Year, _focusedDate.Month, 1);
        if (focusedMonth != _displayedMonth)
        {
            _displayedMonth = focusedMonth;
            // Month changed - the @key directive will recreate the tbody,
            // so we need to refocus the calendar container after render
            _needsRefocus = true;
            _ = NotifyMonthChanged();
        }
    }

    /// <summary>
    /// Checks if the date is the currently focused date (for keyboard navigation).
    /// Only shows focus ring when the calendar container has focus.
    /// Returns true only for the exact date matching _focusedDate when _hasFocus is true.
    /// </summary>
    private bool IsFocused(DateOnly date)
    {
        // Must have focus on the calendar container
        if (!_hasFocus) return false;
        
        // Only the exact focused date gets the ring (DateOnly compares by value: year, month, day)
        return date == _focusedDate;
    }

    private void OnFocus() => _hasFocus = true;
    private void OnBlur()
    {
        _hasFocus = false;
        // Trigger re-render to remove focus ring when focus leaves the calendar
        StateHasChanged();
    }
    private void OnFocusIn() => _hasFocus = true;

    private bool CanNavigatePrevious =>
        !MinDate.HasValue || 
        new DateOnly(_displayedMonth.Year, _displayedMonth.Month, 1).AddMonths(-1) >= new DateOnly(MinDate.Value.Year, MinDate.Value.Month, 1);

    private bool CanNavigateNext =>
        !MaxDate.HasValue ||
        new DateOnly(_displayedMonth.Year, _displayedMonth.Month, 1).AddMonths(1) <= new DateOnly(MaxDate.Value.Year, MaxDate.Value.Month, 1);

    private void PreviousMonth()
    {
        if (CanNavigatePrevious)
        {
            _displayedMonth = _displayedMonth.AddMonths(-1);
            _ = NotifyMonthChanged();
        }
    }

    private void NextMonth()
    {
        if (CanNavigateNext)
        {
            _displayedMonth = _displayedMonth.AddMonths(1);
            _ = NotifyMonthChanged();
        }
    }

    private async Task SelectDate(DateOnly date)
    {
        if (!IsDateEnabled(date)) return;

        await SelectedDateChanged.InvokeAsync(date);
    }

    private bool IsSelected(DateOnly date) => SelectedDate.HasValue && SelectedDate.Value == date;

    private bool IsRangeStart(DateOnly date) => RangeStart.HasValue && RangeStart.Value == date;
    
    private bool IsRangeEnd(DateOnly date) => RangeEnd.HasValue && RangeEnd.Value == date;
    
    private bool IsInRange(DateOnly date)
    {
        if (!RangeStart.HasValue || !RangeEnd.HasValue) return false;
        return date >= RangeStart.Value && date <= RangeEnd.Value;
    }

    private bool IsToday(DateOnly date) => date == DateOnly.FromDateTime(DateTime.Today);

    private bool IsCurrentMonth(DateOnly date) => 
        date.Year == _displayedMonth.Year && date.Month == _displayedMonth.Month;

    private bool IsDateEnabled(DateOnly date)
    {
        if (MinDate.HasValue && date < MinDate.Value) return false;
        if (MaxDate.HasValue && date > MaxDate.Value) return false;
        if (IsDateDisabled != null && IsDateDisabled(date)) return false;
        return true;
    }

    private IEnumerable<string> GetDayNames()
    {
        var firstDayOfWeek = Culture.DateTimeFormat.FirstDayOfWeek;
        var dayNames = Culture.DateTimeFormat.AbbreviatedDayNames;
        
        for (int i = 0; i < 7; i++)
        {
            var index = ((int)firstDayOfWeek + i) % 7;
            var dayName = dayNames[index];
            yield return dayName.Substring(0, Math.Min(dayName.Length, 2));
        }
    }

    private IEnumerable<DateOnly?[]> GetWeeks()
    {
        var firstDayOfWeek = Culture.DateTimeFormat.FirstDayOfWeek;
        var firstOfMonth = new DateOnly(_displayedMonth.Year, _displayedMonth.Month, 1);
        var daysInMonth = DateTime.DaysInMonth(_displayedMonth.Year, _displayedMonth.Month);

        var currentDate = firstOfMonth;
        var dayOfWeek = (int)currentDate.DayOfWeek;
        var firstDayOffset = (dayOfWeek - (int)firstDayOfWeek + 7) % 7;

        var weeks = new List<DateOnly?[]>();
        var week = new DateOnly?[7];

        // Fill in empty days before the first of the month
        for (int i = 0; i < firstDayOffset; i++)
        {
            week[i] = null;
        }

        // Fill in the days of the month
        for (int day = 1; day <= daysInMonth; day++)
        {
            var date = new DateOnly(_displayedMonth.Year, _displayedMonth.Month, day);
            var position = (firstDayOffset + day - 1) % 7;

            if (position == 0 && day > 1)
            {
                weeks.Add(week);
                week = new DateOnly?[7];
            }

            week[position] = date;
        }

        // Add the last week
        weeks.Add(week);

        return weeks;
    }

    /// <summary>
    /// Notifies the parent component when the displayed month changes.
    /// </summary>
    private async Task NotifyMonthChanged()
    {
        if (DisplayedMonthChanged.HasDelegate)
        {
            await DisplayedMonthChanged.InvokeAsync(_displayedMonth);
        }
    }

    private string GetPrevNavButtonClass()
    {
        return "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors " +
               "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 " +
               "disabled:pointer-events-none disabled:opacity-50 border border-input bg-background hover:bg-accent hover:text-accent-foreground " +
               "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100 absolute left-1";
    }

    private string GetNextNavButtonClass()
    {
        return "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors " +
               "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 " +
               "disabled:pointer-events-none disabled:opacity-50 border border-input bg-background hover:bg-accent hover:text-accent-foreground " +
               "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100 absolute right-1";
    }

    private string GetDayClass(DateOnly date)
    {
        // Note: We don't use focus-visible:ring styles here because we manage focus rings programmatically
        // via IsFocused() to prevent duplicate focus rings when Blazor reuses DOM elements during month changes
        var baseClass = "inline-flex h-9 w-9 items-center justify-center whitespace-nowrap rounded-md text-sm font-normal ring-offset-background transition-colors " +
                       "focus-visible:outline-none " +
                       "disabled:pointer-events-none disabled:opacity-50 hover:bg-accent hover:text-accent-foreground";

        var classes = new List<string> { baseClass };

        // Range selection styling
        var isRangeStart = IsRangeStart(date);
        var isRangeEnd = IsRangeEnd(date);
        var inRange = IsInRange(date);

        if (isRangeStart || isRangeEnd || IsSelected(date))
        {
            classes.Add("bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground");
        }
        else if (inRange)
        {
            classes.Add("bg-accent text-accent-foreground");
        }
        else if (IsToday(date))
        {
            classes.Add("bg-accent text-accent-foreground");
        }

        // Add focus ring for keyboard navigation
        if (IsFocused(date) && !IsSelected(date) && !isRangeStart && !isRangeEnd)
        {
            classes.Add("ring-2 ring-ring/50 ring-offset-2");
        }

        if (!IsCurrentMonth(date))
        {
            classes.Add("text-muted-foreground opacity-50");
        }

        if (!IsDateEnabled(date))
        {
            classes.Add("text-muted-foreground opacity-50");
        }

        return string.Join(" ", classes);
    }

    private string GetDropdownClass()
    {
        return "h-7 px-2 text-sm font-medium rounded-md border border-input bg-background " +
               "hover:bg-accent hover:text-accent-foreground cursor-pointer " +
               "focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2";
    }

    private Dictionary<string, object> GetAttributes()
    {
        // Apply border, shadow, default cursor, and intrinsic width at container level
        // Using inline-block for intrinsic width since w-fit may not be in Tailwind build
        var baseClass = "inline-block bg-background no-focus-ring p-3 rounded-md border shadow-sm cursor-default";
        var classValue = string.IsNullOrEmpty(Class) ? baseClass : $"{baseClass} {Class}";

        var attributes = new Dictionary<string, object>
        {
            ["class"] = classValue
        };

        if (AdditionalAttributes != null)
        {
            foreach (var kvp in AdditionalAttributes.Where(kvp => kvp.Key != "class"))
            {
                attributes[kvp.Key] = kvp.Value;
            }
        }

        return attributes;
    }
=======
    #endregion

    #region Date Selection

    private async Task SelectDate(DateTime date)
    {
        if (IsDisabled(date)) return;

        // Reset keyboard navigation mode on click selection
        _isKeyboardNavigating = false;
        _focusedDate = date;

        Selected = date;
        await SelectedChanged.InvokeAsync(date);
        await OnSelect.InvokeAsync(date);
    }

    private bool IsDisabled(DateTime date)
    {
        if (MinDate.HasValue && date < MinDate.Value.Date) return true;
        if (MaxDate.HasValue && date > MaxDate.Value.Date) return true;
        if (DisabledDates != null && DisabledDates(date)) return true;
        return false;
    }

    private List<List<DateTime?>> GetWeeksInMonth()
    {
        if (_cachedWeeks != null)
            return _cachedWeeks;

        _cachedWeeks = BuildWeeksInMonth();
        return _cachedWeeks;
    }

    private List<List<DateTime?>> BuildWeeksInMonth()
    {
        var weeks = new List<List<DateTime?>>();
        var firstOfMonth = new DateTime(DisplayDate.Year, DisplayDate.Month, 1);
        var lastOfMonth = firstOfMonth.AddMonths(1).AddDays(-1);

        // Find the start date (first day of the first week)
        var startDate = firstOfMonth;
        while (startDate.DayOfWeek != FirstDayOfWeek)
        {
            startDate = startDate.AddDays(-1);
        }

        var currentDate = startDate;
        while (currentDate <= lastOfMonth || weeks.Count < 6)
        {
            var week = new List<DateTime?>();
            for (int i = 0; i < 7; i++)
            {
                if (currentDate.Month == DisplayDate.Month)
                {
                    week.Add(currentDate);
                }
                else
                {
                    // Show outside days if enabled, otherwise null (empty cell)
                    week.Add(ShowOutsideDays ? currentDate : null);
                }
                currentDate = currentDate.AddDays(1);
            }
            weeks.Add(week);

            // Stop if we've gone past the last of the month and filled at least 5 weeks
            if (currentDate.Month != DisplayDate.Month && weeks.Count >= 5)
            {
                break;
            }
        }

        return weeks;
    }

    private string GetCellClasses(DateTime? day, bool isSelected)
    {
        string baseClass;
        if (!day.HasValue)
            baseClass = CellEmptyClasses;
        else if (isSelected)
            baseClass = CellSelectedClasses;
        else
            baseClass = CellBaseClasses;

        return string.IsNullOrEmpty(CellClass) ? baseClass : ClassNames.cn(baseClass, CellClass);
    }

    private string GetDayClasses(DateTime date, bool isSelected, bool isDisabled, bool isFocused)
    {
        string baseClass;
        if (isSelected)
            baseClass = DaySelectedClasses;
        else if (isDisabled)
            baseClass = DayDisabledClasses;
        else if (date.Date == DateTime.Today)
            baseClass = DayTodayClasses;
        else
            baseClass = DayBaseClasses;

        // Add keyboard focus ring (distinct from :focus-visible for programmatic focus)
        if (isFocused && _isKeyboardNavigating && !isSelected)
        {
            baseClass = ClassNames.cn(baseClass, "ring-2 ring-ring ring-offset-2");
        }

        return string.IsNullOrEmpty(DayClass) ? baseClass : ClassNames.cn(baseClass, DayClass);
    }

    #endregion

    /// <summary>
    /// Determines whether the component should re-render based on tracked state changes.
    /// This optimization reduces unnecessary render cycles.
    /// </summary>
    protected override bool ShouldRender()
    {
        var selectedChanged = _lastSelected != Selected;
        var displayDateChanged = _lastDisplayDate != _displayDate;
        var minDateChanged = _lastMinDate != MinDate;
        var maxDateChanged = _lastMaxDate != MaxDate;
        var dropdownsChanged = _lastShowMonthYearDropdowns != ShowMonthYearDropdowns;
        var focusedDateChanged = _lastFocusedDate != _focusedDate;
        var keyboardNavigatingChanged = _lastIsKeyboardNavigating != _isKeyboardNavigating;

        if (selectedChanged || displayDateChanged || minDateChanged || maxDateChanged ||
            dropdownsChanged || focusedDateChanged || keyboardNavigatingChanged)
        {
            _lastSelected = Selected;
            _lastDisplayDate = _displayDate;
            _lastMinDate = MinDate;
            _lastMaxDate = MaxDate;
            _lastShowMonthYearDropdowns = ShowMonthYearDropdowns;
            _lastFocusedDate = _focusedDate;
            _lastIsKeyboardNavigating = _isKeyboardNavigating;
            return true;
        }

        return false;
    }

    /// <summary>
    /// Gets the computed CSS classes for the calendar container.
    /// </summary>
    private string CssClass => ClassNames.cn(
        "p-3",
        Class
    );
>>>>>>> 8835bfed9859e4bf8349954ac05f732fe9ffddcf
}
