@namespace BlazorUI.Components.Menubar
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

@if (Menu?.IsOpen == true)
{
    <div class="fixed inset-0 z-40" @onclick="HandleOverlayClick" @onclick:stopPropagation="true"></div>
    <div @ref="_contentRef"
         class="@CssClass"
         data-state="open"
         role="menu"
         tabindex="-1"
         data-autofocus
         @onclick:stopPropagation="true"
         @onkeydown="HandleKeyDown"
         @onkeydown:stopPropagation="true"
         @onkeydown:preventDefault="@_shouldPreventDefault">
        @ChildContent
    </div>
}

@code {
    [CascadingParameter]
    public MenubarMenu? Menu { get; set; }

    [CascadingParameter]
    public Menubar? Context { get; set; }

    [Parameter]
    public string? Class { get; set; }

    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    [Parameter]
    public MenubarContentAlign Align { get; set; } = MenubarContentAlign.Start;

    [Parameter]
    public bool Loop { get; set; } = true;

    private ElementReference _contentRef;
    private bool _wasClosed = true;
    private bool _shouldPreventDefault = true;
    private IJSObjectReference? _portalModule;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (Menu?.IsOpen == true && _wasClosed)
        {
            _wasClosed = false;
            try
            {
                // Load portal module and trigger autofocus
                _portalModule ??= await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "import", "./_content/BlazorUI.Primitives/js/primitives/portal.js");
                await _portalModule.InvokeVoidAsync("triggerAutofocus", _contentRef);
            }
            catch
            {
                // Ignore errors during prerendering
            }
        }
        else if (Menu?.IsOpen != true)
        {
            _wasClosed = true;
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_portalModule != null)
        {
            await _portalModule.DisposeAsync();
        }
    }

    private void HandleOverlayClick()
    {
        Menu?.Close();
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (Menu == null) return;

        switch (e.Key)
        {
            case "Escape":
                Menu.Close();
                break;

            case "ArrowDown":
                await NavigateNext();
                break;

            case "ArrowUp":
                await NavigatePrevious();
                break;

            case "Home":
                await FocusFirst();
                break;

            case "End":
                await FocusLast();
                break;

            case "ArrowRight":
                Context?.NavigateToNextMenu();
                break;

            case "ArrowLeft":
                Context?.NavigateToPreviousMenu();
                break;
        }
    }

    private async Task NavigateNext()
    {
        if (Menu == null) return;

        var items = Menu.GetMenuItems();
        var enabledItems = items.Where(i => !i.IsDisabled).ToList();
        if (enabledItems.Count == 0) return;

        var currentIndex = Menu.FocusedIndex;
        int nextIndex;

        if (currentIndex == -1)
        {
            nextIndex = 0;
        }
        else
        {
            var currentItem = currentIndex < items.Count ? items[currentIndex] : null;
            var enabledIndex = currentItem != null ? enabledItems.IndexOf(currentItem) : -1;

            if (enabledIndex == -1)
            {
                nextIndex = 0;
            }
            else if (enabledIndex == enabledItems.Count - 1)
            {
                nextIndex = Loop ? 0 : enabledIndex;
            }
            else
            {
                nextIndex = enabledIndex + 1;
            }
        }

        await FocusEnabledItem(enabledItems, items, nextIndex);
    }

    private async Task NavigatePrevious()
    {
        if (Menu == null) return;

        var items = Menu.GetMenuItems();
        var enabledItems = items.Where(i => !i.IsDisabled).ToList();
        if (enabledItems.Count == 0) return;

        var currentIndex = Menu.FocusedIndex;
        int prevIndex;

        if (currentIndex == -1)
        {
            prevIndex = enabledItems.Count - 1;
        }
        else
        {
            var currentItem = currentIndex < items.Count ? items[currentIndex] : null;
            var enabledIndex = currentItem != null ? enabledItems.IndexOf(currentItem) : -1;

            if (enabledIndex == -1)
            {
                prevIndex = enabledItems.Count - 1;
            }
            else if (enabledIndex == 0)
            {
                prevIndex = Loop ? enabledItems.Count - 1 : 0;
            }
            else
            {
                prevIndex = enabledIndex - 1;
            }
        }

        await FocusEnabledItem(enabledItems, items, prevIndex);
    }

    private async Task FocusFirst()
    {
        if (Menu == null) return;

        var items = Menu.GetMenuItems();
        var enabledItems = items.Where(i => !i.IsDisabled).ToList();
        if (enabledItems.Count == 0) return;

        await FocusEnabledItem(enabledItems, items, 0);
    }

    private async Task FocusLast()
    {
        if (Menu == null) return;

        var items = Menu.GetMenuItems();
        var enabledItems = items.Where(i => !i.IsDisabled).ToList();
        if (enabledItems.Count == 0) return;

        await FocusEnabledItem(enabledItems, items, enabledItems.Count - 1);
    }

    private async Task FocusEnabledItem(List<IMenubarItem> enabledItems, List<IMenubarItem> allItems, int enabledIndex)
    {
        if (enabledIndex < 0 || enabledIndex >= enabledItems.Count) return;

        var item = enabledItems[enabledIndex];
        var absoluteIndex = allItems.IndexOf(item);

        Menu!.SetFocusedIndex(absoluteIndex);
        await item.FocusAsync();
    }

    private string AlignClass => Align switch
    {
        MenubarContentAlign.Start => "left-0",
        MenubarContentAlign.Center => "left-1/2 -translate-x-1/2",
        MenubarContentAlign.End => "right-0",
        _ => "left-0"
    };

    private string CssClass => BlazorUI.Components.Utilities.ClassNames.cn(
        "absolute top-full mt-1 z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out",
        "data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        "data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
        AlignClass,
        Class
    );
}
