@namespace BlazorUI.Components.ContextMenu
<<<<<<< HEAD
@using BlazorUI.Primitives.ContextMenu

@* ContextMenu - styled context menu wrapper *@
<ContextMenuRoot Open="@Open"
                 OpenChanged="OpenChanged"
                 OnOpen="OnOpen"
                 OnClose="OnClose">
    @ChildContent
</ContextMenuRoot>

@code {
    /// <summary>
    /// The child content to render.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Controls whether the context menu is open.
    /// </summary>
    [Parameter]
    public bool? Open { get; set; }

    /// <summary>
    /// Event callback invoked when the open state changes.
    /// </summary>
    [Parameter]
    public EventCallback<bool> OpenChanged { get; set; }

    /// <summary>
    /// Event callback invoked when the context menu opens.
    /// </summary>
    [Parameter]
    public EventCallback<(double X, double Y)> OnOpen { get; set; }

    /// <summary>
    /// Event callback invoked when the context menu closes.
    /// </summary>
    [Parameter]
    public EventCallback OnClose { get; set; }
=======
@using Microsoft.JSInterop
@inject IJSRuntime JS
@implements IAsyncDisposable

<CascadingValue Value="this" IsFixed="false">
    @ChildContent
</CascadingValue>

@code {
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    [Parameter]
    public bool? Open { get; set; }

    [Parameter]
    public EventCallback<bool> OpenChanged { get; set; }

    internal bool IsOpen { get; private set; }
    internal double X { get; private set; }
    internal double Y { get; private set; }
    internal int FocusedIndex { get; private set; } = -1;

    private DotNetObjectReference<ContextMenu>? _dotNetRef;
    private List<ContextMenuItem> _menuItems = new();

    protected override void OnInitialized()
    {
        _dotNetRef = DotNetObjectReference.Create(this);
    }

    internal void RegisterMenuItem(ContextMenuItem item)
    {
        if (!_menuItems.Contains(item))
        {
            _menuItems.Add(item);
        }
    }

    internal void UnregisterMenuItem(ContextMenuItem item)
    {
        _menuItems.Remove(item);
    }

    internal List<ContextMenuItem> GetMenuItems() => _menuItems;

    internal void SetFocusedIndex(int index)
    {
        FocusedIndex = index;
        StateHasChanged();
    }

    internal async Task OpenAt(double x, double y)
    {
        X = x;
        Y = y;
        IsOpen = true;
        FocusedIndex = -1;

        if (Open.HasValue)
        {
            await OpenChanged.InvokeAsync(true);
        }

        StateHasChanged();
    }

    internal async Task Close()
    {
        IsOpen = false;
        FocusedIndex = -1;

        if (Open.HasValue)
        {
            await OpenChanged.InvokeAsync(false);
        }

        StateHasChanged();
    }

    [JSInvokable]
    public async Task HandleClickOutside()
    {
        await Close();
    }

    public async ValueTask DisposeAsync()
    {
        _dotNetRef?.Dispose();
    }
>>>>>>> 8835bfed9859e4bf8349954ac05f732fe9ffddcf
}
