@using Microsoft.AspNetCore.Components
@using Microsoft.JSInterop
@implements IAsyncDisposable
@namespace BlazorUI.Components.Motion

@*
    Motion Component - Declarative Animation System
    
    Provides declarative, composable animations using Motion.dev library.
    
    Usage Example:
    
    <Motion Trigger="@MotionTrigger.OnAppear">
        <Presets>
            <FadeIn />
            <ScaleIn From="0.6" />
            <Spring Stiffness="200" Damping="22" />
        </Presets>
        <div>Animated content</div>
    </Motion>
*@

<div @ref="_elementRef" class="@Class" style="@Style">
    @if (StaggerChildren.HasValue && StaggerChildren.Value > 0)
    {
        <CascadingValue Value="@(new MotionContext { StaggerDelay = StaggerChildren.Value })" Name="MotionContext">
            @ChildContent
        </CascadingValue>
    }
    else
    {
        @ChildContent
    }
</div>

@code {
    private ElementReference _elementRef;
    private IJSObjectReference? _jsModule;
    private DotNetObjectReference<Motion>? _dotNetRef;
    private int _animationId = -1;
    private int _observerId = -1;
    private bool _hasAnimated = false;

    /// <summary>
    /// The content to render and animate.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Preset animations to apply (FadeIn, ScaleIn, Spring, etc.).
    /// </summary>
    [Parameter]
    public RenderFragment? Presets { get; set; }

    /// <summary>
    /// When the animation should trigger.
    /// </summary>
    [Parameter]
    public MotionTrigger Trigger { get; set; } = MotionTrigger.OnAppear;

    /// <summary>
    /// Additional CSS classes to apply.
    /// </summary>
    [Parameter]
    public string? Class { get; set; }

    /// <summary>
    /// Additional inline styles to apply.
    /// </summary>
    [Parameter]
    public string? Style { get; set; }

    /// <summary>
    /// Options for IntersectionObserver when Trigger is OnInView.
    /// </summary>
    [Parameter]
    public InViewOptions? InViewOptions { get; set; }

    /// <summary>
    /// Stagger delay for child animations in seconds.
    /// </summary>
    [Parameter]
    public double? StaggerChildren { get; set; }

    /// <summary>
    /// Whether to respect user's reduced motion preference.
    /// Default: true
    /// </summary>
    [Parameter]
    public bool RespectReducedMotion { get; set; } = true;

    /// <summary>
    /// Custom keyframes to animate (alternative to using presets).
    /// </summary>
    [Parameter]
    public List<MotionKeyframe>? Keyframes { get; set; }

    /// <summary>
    /// Animation options (duration, delay, easing, etc.).
    /// </summary>
    [Parameter]
    public MotionOptions? Options { get; set; }

    /// <summary>
    /// Spring physics options (overrides standard easing).
    /// </summary>
    [Parameter]
    public SpringOptions? Spring { get; set; }

    [Inject]
    private IJSRuntime JSRuntime { get; set; } = default!;

    [CascadingParameter(Name = "MotionContext")]
    private MotionContext? Context { get; set; }

    // Internal state for preset collection
    internal List<IMotionPreset> CollectedPresets { get; } = new();
    
    protected override void OnInitialized()
    {
        // If we're a child in a stagger context, get our index
        if (Context != null)
        {
            Context.ChildIndex = Context.GetNextChildIndex();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                _jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "import", "./_content/BlazorUI.Components/js/motion.js");

                _dotNetRef = DotNetObjectReference.Create(this);
            }
            catch (JSException ex)
            {
                Console.WriteLine($"Motion: Failed to load module - {ex.Message}");
                return;
            }

            // Set up trigger
            if (Trigger == MotionTrigger.OnAppear)
            {
                await AnimateAsync();
            }
            else if (Trigger == MotionTrigger.OnInView)
            {
                await SetupInViewTriggerAsync();
            }
        }
    }

    /// <summary>
    /// Manually trigger the animation.
    /// Only works when Trigger is set to Manual.
    /// </summary>
    public async Task PlayAsync()
    {
        if (Trigger == MotionTrigger.Manual)
        {
            await AnimateAsync();
        }
    }

    private async Task SetupInViewTriggerAsync()
    {
        if (_jsModule == null || _dotNetRef == null) return;

        try
        {
            var options = InViewOptions ?? new InViewOptions();
            _observerId = await _jsModule.InvokeAsync<int>(
                "setupInViewObserver",
                _elementRef,
                options,
                _dotNetRef);
        }
        catch (JSException ex)
        {
            Console.WriteLine($"Motion: Failed to setup IntersectionObserver - {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task OnIntersecting()
    {
        if (!_hasAnimated || InViewOptions?.Once == false)
        {
            await AnimateAsync();
            _hasAnimated = true;
        }
    }

    private async Task AnimateAsync()
    {
        if (_jsModule == null) return;

        // Check for reduced motion preference
        if (RespectReducedMotion)
        {
            var prefersReducedMotion = await CheckReducedMotionAsync();
            if (prefersReducedMotion)
            {
                // Skip animation or use simplified version
                return;
            }
        }

        try
        {
            // Collect keyframes from presets or use custom keyframes
            List<MotionKeyframe> keyframes;
            MotionOptions? options = Options;
            SpringOptions? spring = Spring;

            if (CollectedPresets.Any())
            {
                keyframes = new List<MotionKeyframe>();
                
                // Note: When multiple presets are combined, their keyframes are concatenated.
                // For best results, use presets that animate different properties (e.g., FadeIn + ScaleIn).
                // If presets animate the same property, the last preset's keyframes will take precedence.
                foreach (var preset in CollectedPresets)
                {
                    keyframes.AddRange(preset.GetKeyframes());
                    
                    // Merge options from presets
                    if (preset.GetOptions() != null)
                    {
                        options = MergeOptions(options, preset.GetOptions());
                    }
                    
                    // Use spring from preset if available
                    if (preset.GetSpringOptions() != null)
                    {
                        spring = preset.GetSpringOptions();
                    }
                }
            }
            else if (Keyframes != null && Keyframes.Any())
            {
                keyframes = Keyframes;
            }
            else
            {
                // No animation to perform
                return;
            }

            // Apply stagger if in context
            if (Context != null && Context.StaggerDelay > 0)
            {
                options = options ?? new MotionOptions();
                options.Delay = (options.Delay ?? 0) + (Context.ChildIndex * Context.StaggerDelay);
            }

            _animationId = await _jsModule.InvokeAsync<int>(
                "motionAnimate",
                _elementRef,
                keyframes,
                options,
                spring);
        }
        catch (JSException ex)
        {
            Console.WriteLine($"Motion: Animation failed - {ex.Message}");
        }
    }

    private async Task<bool> CheckReducedMotionAsync()
    {
        try
        {
            if (_jsModule != null)
            {
                return await _jsModule.InvokeAsync<bool>("checkReducedMotion");
            }
            
            // Fallback if module not loaded
            return false;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Motion: Failed to check reduced motion preference - {ex.Message}");
            return false;
        }
    }

    private MotionOptions? MergeOptions(MotionOptions? current, MotionOptions? preset)
    {
        if (current == null) return preset;
        if (preset == null) return current;

        // User-specified options (current) take precedence over preset defaults
        return new MotionOptions
        {
            Duration = current.Duration ?? preset.Duration,
            Delay = current.Delay ?? preset.Delay,
            Easing = current.Easing ?? preset.Easing,
            CustomEasing = current.CustomEasing ?? preset.CustomEasing,
            Repeat = current.Repeat ?? preset.Repeat,
            RepeatReverse = current.RepeatReverse ?? preset.RepeatReverse,
            RepeatDelay = current.RepeatDelay ?? preset.RepeatDelay,
            Fill = current.Fill ?? preset.Fill,
            Direction = current.Direction ?? preset.Direction
        };
    }

    public async ValueTask DisposeAsync()
    {
        if (_jsModule != null)
        {
            if (_animationId != -1)
            {
                try
                {
                    await _jsModule.InvokeVoidAsync("stopAnimation", _animationId);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Motion: Failed to stop animation during disposal - {ex.Message}");
                }
            }

            if (_observerId != -1)
            {
                try
                {
                    await _jsModule.InvokeVoidAsync("cleanupInViewObserver", _observerId);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Motion: Failed to cleanup observer during disposal - {ex.Message}");
                }
            }

            try
            {
                await _jsModule.DisposeAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Motion: Failed to dispose JS module - {ex.Message}");
            }
        }

        _dotNetRef?.Dispose();
    }
}
