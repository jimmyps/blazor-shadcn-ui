@using Microsoft.AspNetCore.Components
@using Microsoft.JSInterop
@implements IAsyncDisposable
@namespace BlazorUI.Components.Motion

@*
    Motion Component - Declarative Animation System
    
    Provides declarative, composable animations using Motion.dev library.
    
    Usage Example:
    
    <Motion Trigger="@MotionTrigger.OnAppear">
        <Presets>
            <FadeIn />
            <ScaleIn From="0.6" />
            <Spring Stiffness="200" Damping="22" />
        </Presets>
        <div>Animated content</div>
    </Motion>
*@

<div @ref="_elementRef" class="@Class" style="@Style">
    @ChildContent
</div>

@code {
    private ElementReference _elementRef;
    private IJSObjectReference? _jsModule;
    private DotNetObjectReference<Motion>? _dotNetRef;
    private int _animationId = -1;
    private int _observerId = -1;
    private bool _hasAnimated = false;

    /// <summary>
    /// The content to render and animate.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Preset animations to apply (FadeIn, ScaleIn, Spring, etc.).
    /// </summary>
    [Parameter]
    public RenderFragment? Presets { get; set; }

    /// <summary>
    /// When the animation should trigger.
    /// </summary>
    [Parameter]
    public MotionTrigger Trigger { get; set; } = MotionTrigger.OnAppear;

    /// <summary>
    /// Additional CSS classes to apply.
    /// </summary>
    [Parameter]
    public string? Class { get; set; }

    /// <summary>
    /// Additional inline styles to apply.
    /// </summary>
    [Parameter]
    public string? Style { get; set; }

    /// <summary>
    /// Options for IntersectionObserver when Trigger is OnInView.
    /// </summary>
    [Parameter]
    public InViewOptions? InViewOptions { get; set; }

    /// <summary>
    /// Stagger delay for child animations in seconds.
    /// </summary>
    [Parameter]
    public double? StaggerChildren { get; set; }

    /// <summary>
    /// Whether to respect user's reduced motion preference.
    /// Default: true
    /// </summary>
    [Parameter]
    public bool RespectReducedMotion { get; set; } = true;

    /// <summary>
    /// Custom keyframes to animate (alternative to using presets).
    /// </summary>
    [Parameter]
    public List<MotionKeyframe>? Keyframes { get; set; }

    /// <summary>
    /// Animation options (duration, delay, easing, etc.).
    /// </summary>
    [Parameter]
    public MotionOptions? Options { get; set; }

    /// <summary>
    /// Spring physics options (overrides standard easing).
    /// </summary>
    [Parameter]
    public SpringOptions? Spring { get; set; }

    [Inject]
    private IJSRuntime JSRuntime { get; set; } = default!;

    [CascadingParameter(Name = "MotionContext")]
    private MotionContext? Context { get; set; }

    // Internal state for preset collection
    internal List<IMotionPreset> CollectedPresets { get; } = new();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                _jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "import", "./_content/BlazorUI.Components/js/motion.js");

                _dotNetRef = DotNetObjectReference.Create(this);
            }
            catch (JSException ex)
            {
                Console.WriteLine($"Motion: Failed to load module - {ex.Message}");
                return;
            }

            // Set up trigger
            if (Trigger == MotionTrigger.OnAppear)
            {
                await AnimateAsync();
            }
            else if (Trigger == MotionTrigger.OnInView)
            {
                await SetupInViewTriggerAsync();
            }
        }
    }

    /// <summary>
    /// Manually trigger the animation.
    /// Only works when Trigger is set to Manual.
    /// </summary>
    public async Task PlayAsync()
    {
        if (Trigger == MotionTrigger.Manual)
        {
            await AnimateAsync();
        }
    }

    private async Task SetupInViewTriggerAsync()
    {
        if (_jsModule == null || _dotNetRef == null) return;

        try
        {
            var options = InViewOptions ?? new InViewOptions();
            _observerId = await _jsModule.InvokeAsync<int>(
                "setupInViewObserver",
                _elementRef,
                options,
                _dotNetRef);
        }
        catch (JSException ex)
        {
            Console.WriteLine($"Motion: Failed to setup IntersectionObserver - {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task OnIntersecting()
    {
        if (!_hasAnimated || InViewOptions?.Once == false)
        {
            await AnimateAsync();
            _hasAnimated = true;
        }
    }

    private async Task AnimateAsync()
    {
        if (_jsModule == null) return;

        // Check for reduced motion preference
        if (RespectReducedMotion)
        {
            var prefersReducedMotion = await CheckReducedMotionAsync();
            if (prefersReducedMotion)
            {
                // Skip animation or use simplified version
                return;
            }
        }

        try
        {
            // Collect keyframes from presets or use custom keyframes
            List<MotionKeyframe> keyframes;
            MotionOptions? options = Options;
            SpringOptions? spring = Spring;

            if (CollectedPresets.Any())
            {
                keyframes = new List<MotionKeyframe>();
                foreach (var preset in CollectedPresets)
                {
                    keyframes.AddRange(preset.GetKeyframes());
                    
                    // Merge options from presets
                    if (preset.GetOptions() != null)
                    {
                        options = MergeOptions(options, preset.GetOptions());
                    }
                    
                    // Use spring from preset if available
                    if (preset.GetSpringOptions() != null)
                    {
                        spring = preset.GetSpringOptions();
                    }
                }
            }
            else if (Keyframes != null && Keyframes.Any())
            {
                keyframes = Keyframes;
            }
            else
            {
                // No animation to perform
                return;
            }

            // Apply stagger if in context
            if (Context != null && Context.StaggerDelay > 0)
            {
                options = options ?? new MotionOptions();
                options.Delay = (options.Delay ?? 0) + (Context.ChildIndex * Context.StaggerDelay);
            }

            _animationId = await _jsModule.InvokeAsync<int>(
                "motionAnimate",
                _elementRef,
                keyframes,
                options,
                spring);
        }
        catch (JSException ex)
        {
            Console.WriteLine($"Motion: Animation failed - {ex.Message}");
        }
    }

    private async Task<bool> CheckReducedMotionAsync()
    {
        try
        {
            return await JSRuntime.InvokeAsync<bool>(
                "eval",
                "window.matchMedia('(prefers-reduced-motion: reduce)').matches");
        }
        catch
        {
            return false;
        }
    }

    private MotionOptions? MergeOptions(MotionOptions? current, MotionOptions? preset)
    {
        if (current == null) return preset;
        if (preset == null) return current;

        return new MotionOptions
        {
            Duration = preset.Duration ?? current.Duration,
            Delay = preset.Delay ?? current.Delay,
            Easing = preset.Easing ?? current.Easing,
            CustomEasing = preset.CustomEasing ?? current.CustomEasing,
            Repeat = preset.Repeat ?? current.Repeat,
            RepeatReverse = preset.RepeatReverse ?? current.RepeatReverse,
            RepeatDelay = preset.RepeatDelay ?? current.RepeatDelay,
            Fill = preset.Fill ?? current.Fill,
            Direction = preset.Direction ?? current.Direction
        };
    }

    public async ValueTask DisposeAsync()
    {
        if (_jsModule != null)
        {
            if (_animationId != -1)
            {
                try
                {
                    await _jsModule.InvokeVoidAsync("stopAnimation", _animationId);
                }
                catch { }
            }

            if (_observerId != -1)
            {
                try
                {
                    await _jsModule.InvokeVoidAsync("cleanupInViewObserver", _observerId);
                }
                catch { }
            }

            try
            {
                await _jsModule.DisposeAsync();
            }
            catch { }
        }

        _dotNetRef?.Dispose();
    }
}
