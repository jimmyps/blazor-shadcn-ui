@namespace BlazorUI.Components.Old.Chart
@typeparam TData
@inherits PieChartBase<TData>
@implements IAsyncDisposable
@inject IChartRefreshRegistry? ChartRefreshRegistry

<div class="@ContainerClass" style="position: relative; height: @(Height)px; width: 100%;">
    <canvas @ref="_canvasRef" style="width: 100%; height: 100%;"></canvas>
    @if (IsDonut && CenterContent != null)
    {
        <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
            @CenterContent
        </div>
    }
    
    @if (ShowExportButton && _isInitialized)
    {
        <div style="position: absolute; top: 8px; right: 8px; z-index: 10;">
            <button @onclick="ExportChart" 
                    class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-9 w-9"
                    title="Export chart">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" x2="12" y1="15" y2="3"/>
                </svg>
            </button>
        </div>
    }
</div>

@code {
    private ElementReference _canvasRef;
    private IChartRenderer? _renderer;
    private string? _chartId;
    private bool _isInitialized;
    
    /// <summary>
    /// Refreshes the chart by re-resolving CSS variables and re-applying options.
    /// </summary>
    public async Task RefreshAsync()
    {
        if (_renderer != null && !string.IsNullOrEmpty(_chartId))
        {
            try
            {
                await _renderer.RefreshAsync(_chartId);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"PieChart: Failed to refresh chart: {ex.Message}");
            }
        }
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && Data != null && Data.Any())
        {
            await InitializeChartAsync();
        }
    }
    
    protected override async Task OnParametersSetAsync()
    {
        if (_isInitialized && Data != null && Data.Any())
        {
            await UpdateChartDataAsync();
        }
    }
    
    private async Task InitializeChartAsync()
    {
        try
        {
            _renderer = ChartRendererFactory.CreateRenderer(Engine, JSRuntime);
            
            var chartType = IsDonut ? ChartType.Donut : ChartType.Pie;
            var chartConfig = new ChartConfig
            {
                Type = chartType,
                Responsive = Responsive,
                MaintainAspectRatio = false,
                Data = BuildChartData(),
                Options = BuildChartOptions()
            };
            
            _chartId = await _renderer.InitializeAsync(_canvasRef, chartConfig);
            _isInitialized = true;
            
            // Register with refresh registry for global refresh support
            if (ChartRefreshRegistry != null && !string.IsNullOrEmpty(_chartId))
            {
                ChartRefreshRegistry.Register(_chartId, _renderer);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"PieChart: Failed to initialize chart: {ex.Message}");
        }
    }
    
    private async Task ExportChart()
    {
        if (_renderer == null || string.IsNullOrEmpty(_chartId))
        {
            Console.WriteLine("PieChart: Cannot export - chart not initialized");
            return;
        }
        
        try
        {
            var format = Engine == ChartEngine.ECharts ? ImageFormat.Svg : ImageFormat.Png;
            var dataUrl = await _renderer.ExportAsImageAsync(_chartId, format);
            
            if (string.IsNullOrEmpty(dataUrl))
            {
                Console.WriteLine("PieChart: Export returned empty data URL");
                return;
            }
            
            var extension = format == ImageFormat.Svg ? "svg" : "png";
            var filename = $"{ExportFileName}.{extension}";
            await DownloadFile(dataUrl, filename);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"PieChart: Export failed - {ex.Message}");
        }
    }
    
    private async Task DownloadFile(string dataUrl, string filename)
    {
        var script = @"
            (function(url, name) {
                const link = document.createElement('a');
                link.href = url;
                link.download = name;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            })(arguments[0], arguments[1]);
        ";
        await JSRuntime.InvokeVoidAsync("eval", script, dataUrl, filename);
    }
    
    private async Task UpdateChartDataAsync()
    {
        if (_renderer != null && !string.IsNullOrEmpty(_chartId))
        {
            try
            {
                var chartData = BuildChartData();
                await _renderer.UpdateDataAsync(_chartId, chartData);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to update chart data: {ex.Message}");
            }
        }
    }
    
    private ChartOptions BuildChartOptions()
    {
        return new ChartOptions
        {
            Responsive = Responsive,
            MaintainAspectRatio = false,
            Plugins = new ChartPlugins
            {
                Legend = new LegendConfig 
                { 
                    Display = ShowLegend,
                    Position = MapLegendPosition(LegendPosition)
                },
                Tooltip = new TooltipConfig { Enabled = ShowTooltip }
            },
            Cutout = IsDonut ? $"{DonutInnerRadius * 100}%" : null,
            Animation = new ChartAnimationConfig
            {
                Duration = DisableAnimations ? 0 : (Animation?.Duration ?? 750),
                Easing = Animation?.Easing ?? AnimationEasing.EaseInOutQuart
            }
        };
    }
    
    private ChartData BuildChartData()
    {
        if (Data == null || !Data.Any())
        {
            return new ChartData
            {
                Labels = Array.Empty<string>(),
                Datasets = Array.Empty<ChartDataset>()
            };
        }
        
        var labels = ExtractLabels();
        var values = ExtractValues();
        var colors = GenerateColors(values.Length);
        
        return new ChartData
        {
            Labels = labels,
            Datasets = new[]
            {
                new ChartDataset
                {
                    Data = values,
                    BackgroundColor = string.Join(",", colors), // Multiple colors as comma-separated
                    BorderColor = string.Join(",", colors),
                    BorderWidth = 1,
                    BackgroundColors = colors // Keep array for ECharts converter
                }
            }
        };
    }
    
    private string[] ExtractLabels()
    {
        if (Data == null || !Data.Any()) return Array.Empty<string>();
        
        if (!string.IsNullOrEmpty(LabelDataKey))
        {
            return Data.Select(item =>
            {
                var prop = item?.GetType().GetProperty(LabelDataKey);
                return prop?.GetValue(item)?.ToString() ?? "";
            }).ToArray();
        }
        
        return Data.Select((_, i) => $"Item {i + 1}").ToArray();
    }
    
    private double[] ExtractValues()
    {
        if (Data == null || !Data.Any()) return Array.Empty<double>();
        
        if (string.IsNullOrEmpty(ValueDataKey))
        {
            return Array.Empty<double>();
        }
        
        return Data.Select(item =>
        {
            var prop = item?.GetType().GetProperty(ValueDataKey);
            var value = prop?.GetValue(item);
            
            if (value == null) return 0.0;
            
            return Convert.ToDouble(value);
        }).ToArray();
    }
    
    private string[] GenerateColors(int count)
    {
        var baseColors = new[]
        {
            "var(--chart-1)",
            "var(--chart-2)",
            "var(--chart-3)",
            "var(--chart-4)",
            "var(--chart-5)"
        };
        
        var colors = new List<string>();
        for (int i = 0; i < count; i++)
        {
            colors.Add(baseColors[i % baseColors.Length]);
        }
        
        return colors.ToArray();
    }
    
    private string MapLegendPosition(LegendPosition position)
    {
        return position switch
        {
            LegendPosition.Top => "top",
            LegendPosition.Right => "right",
            LegendPosition.Bottom => "bottom",
            LegendPosition.Left => "left",
            _ => "top"
        };
    }
    
    
    public async ValueTask DisposeAsync()
    {
        // Unregister from refresh registry
        if (ChartRefreshRegistry != null && !string.IsNullOrEmpty(_chartId))
        {
            ChartRefreshRegistry.Unregister(_chartId);
        }
        
        if (_renderer != null && !string.IsNullOrEmpty(_chartId))
        {
            try
            {
                await _renderer.DestroyAsync(_chartId);
            }
            catch
            {
                // Ignore disposal errors
            }
        }
        
        if (_renderer != null)
        {
            try
            {
                await _renderer.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
    }
}
