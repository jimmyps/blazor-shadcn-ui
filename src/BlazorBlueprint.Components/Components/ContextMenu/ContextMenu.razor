@namespace BlazorBlueprint.Components.ContextMenu
@using Microsoft.JSInterop
@inject IJSRuntime JS
@implements IAsyncDisposable

<CascadingValue Value="this" IsFixed="false">
    @ChildContent
</CascadingValue>

@code {
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    [Parameter]
    public bool? Open { get; set; }

    [Parameter]
    public EventCallback<bool> OpenChanged { get; set; }

    internal bool IsOpen { get; private set; }
    internal double X { get; private set; }
    internal double Y { get; private set; }
    internal int FocusedIndex { get; private set; } = -1;

    private DotNetObjectReference<ContextMenu>? _dotNetRef;
    private List<ContextMenuItem> _menuItems = new();

    protected override void OnInitialized()
    {
        _dotNetRef = DotNetObjectReference.Create(this);
    }

    internal void RegisterMenuItem(ContextMenuItem item)
    {
        if (!_menuItems.Contains(item))
        {
            _menuItems.Add(item);
        }
    }

    internal void UnregisterMenuItem(ContextMenuItem item)
    {
        _menuItems.Remove(item);
    }

    internal List<ContextMenuItem> GetMenuItems() => _menuItems;

    internal void SetFocusedIndex(int index)
    {
        FocusedIndex = index;
        StateHasChanged();
    }

    internal async Task OpenAt(double x, double y)
    {
        X = x;
        Y = y;
        IsOpen = true;
        FocusedIndex = -1;

        if (Open.HasValue)
        {
            await OpenChanged.InvokeAsync(true);
        }

        StateHasChanged();
    }

    internal async Task Close()
    {
        IsOpen = false;
        FocusedIndex = -1;

        if (Open.HasValue)
        {
            await OpenChanged.InvokeAsync(false);
        }

        StateHasChanged();
    }

    [JSInvokable]
    public async Task HandleClickOutside()
    {
        await Close();
    }

    public ValueTask DisposeAsync()
    {
        _dotNetRef?.Dispose();
        return ValueTask.CompletedTask;
    }
}
